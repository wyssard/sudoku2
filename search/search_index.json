{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sudokumentation","text":""},{"location":"#welcome-to-the-documentation-of-the-sudoku2-package","title":"Welcome to the documentation of the sudoku2 package!","text":"<p>These docs shall give you an overview of the possible applications of the package; On the one hand, its built in solver can be comfortably used to guide you step-by-step to the solution of a Sudoku puzzle. On the other hand, the package provides an API which lets you easily extend the capabilities of the basic solver by adding custom solving algorithms or by implementing any arbitrary Python frontend to render the individual solving steps. </p> <p>Warning</p> <p>Even the core functionality of the Package is still in development. Both the API and the features that are abstracted by it may still change heavily. Proceed with caution if you intend to integrate this package in your own project. Moreover, if you are reading this from a development branch, the docs may not exactly correspond to the present state of the code.</p>"},{"location":"#contents","title":"Contents","text":"<p>Info</p> <p>For any use of the package that goes beyond the Standard Solver, it's strongly recommended to start the journey through these docs with the description of the Solving Process. </p> <p>If you intend to use the package as a stand-alone tool to solve Sudoku puzzles, please refer to:</p> <ul> <li>Standard Solver - simple functional access to the pre-built solver</li> <li>Custom Solver - create a custom solver by explicitly deciding what solving algorithms to use and what solving steps to render</li> </ul> <p>If you're interested in modifying the basic capabilities or to use the solver backend in your own project, refer to the API Guide.</p>"},{"location":"api_guide/","title":"API Guide","text":""},{"location":"custom_solver/","title":"Create a Custom Solver","text":"<p>This document aims at explaining the API of the library by walking you through the process of assembling a custom solver object. We will thereby create an implementation for a very basic solving algorithm and </p>"},{"location":"solving_process/","title":"Solving Process","text":"<p>When working with the Custom Solver or when making use of the API, your interaction with the package goes beyond the simplified functional access and you will be confronted with the objects that, e.g., represent the solving algorithms of the rendering frontend. In order to understand how these objects interact with each other, a basic understanding of the solving procedure, illustrated by the flowchart below, is indispensible.</p> <p>We come back to some specific nodes of the diagram when discussing the API or the Custom Solver generator.</p>"},{"location":"solving_process/#a-word-of-caution","title":"A Word of Caution","text":"<p>Since there are some severe differences between the implemented solving algorithms, the API does not force you (so far) to entirely stick to the prescription suggested by the diagram. For example, you are free to decide whether to implement a loop over tiles or to replace it by a better suiting approach.</p> <p>Note</p> <p>Future versions may address this inconvenience by providing a further abstraction that ultimately forces you to stick to the suggested prescription by means of an intermediate abstract class. Since, however, the procedures that are not abstracted are very simple (they come in form of simple conditions or loops), further abstraction may also be omitted completely, to make the code more readable.</p>"},{"location":"solving_process/#flowchart","title":"Flowchart","text":"<pre><code>flowchart\n    init([Launch Solver]) --&gt; InitialAlgorithm[Use initial Algorithm]\n    InitialAlgorithm --&gt; LaunchSolver[Launch Algorithm] \n    LaunchSolver --&gt; Solved{Puzzle \\nsolved?}\n\n    Solved --yes--&gt; Return([Return Solved Puzzle])\n\n    Solved --no---&gt; SolverLoop[Loop over Tiles]\n    SolverLoop --&gt; Increase[Next Tile]\n    Increase --&gt; TerminateLoop{Last \\nitem?}\n\n    TerminateLoop --Yes--&gt; CheckSuccess{Algorithm \\ncould remove \\nat least one\\n candidate?}\n\n    CheckSuccess --No---&gt; FallbackLeft{Fallback \\nAlgorithm \\nspecified?}\n    FallbackLeft --yes--&gt; Fallback[Continue with Fallback Algorithm]\n\n    CheckSuccess --yes--&gt; Advance[Continue with less elaborate Algorithm]\n    Fallback &amp; Advance --&gt; LaunchSolver\n\n    FallbackLeft --no--&gt; Fail([Can't solve puzzle])\n\n    TerminateLoop --No--&gt; FindPattern[[Search for Pattern on the Sudoku grid \\nthat lets us deduce \\nwhat Candidates we can remove \\nfrom neighboring Tiles]]\n    FindPattern --&gt; PatternFound{Pattern \\nmatched?}\n\n    PatternFound --no--&gt; Increase\n\n    PatternFound --yes--&gt; TryRemove[Check if there are any Candidates \\nconcerned by the Pattern]\n    TryRemove --&gt; ToRemove{Concerned\\ncandidates\\nfound?}\n\n    ToRemove --no--&gt; Increase\n\n    ToRemove --yes--&gt; Remove[Remove Candidates]\n    Remove --&gt; Render{{Render Solving Step}}\n    Render --&gt; Trigger[Trigger Next Step]\n    Trigger --&gt; CleanUp[[Update Routine involving very basic Solving Algorithms]]\n    CleanUp --&gt; Increase\n</code></pre>"},{"location":"standard_solvers/","title":"Using the Standard Solver","text":""},{"location":"api/modules/","title":"Modules","text":"<ul> <li>sudoku<ul> <li>consolesolver</li> <li>formatting</li> <li>solvertools</li> <li>solvingmethods</li> <li>stepping</li> <li>structure</li> </ul> </li> </ul>"},{"location":"api/sudoku/consolesolver/","title":"consolesolver","text":"<p>Example module to illustrate a coupling of the solver to the console as  frontend. Therefore, a corresponding <code>Trigger</code> and <code>Formatter</code> class must be implemented.</p>"},{"location":"api/sudoku/consolesolver/#sudoku.consolesolver.ConsoleFormatter","title":"<code>ConsoleFormatter</code>","text":"<p>         Bases: <code>BlankFormatter</code></p> <p>Basic formatter to print the solutions steps, i.e. the partially solved puzzle, to the console. Use the <code>flush</code> attribute to decide whether the  solution steps are stringed together in the console or if the previous step is consecutively removed.</p>"},{"location":"api/sudoku/consolesolver/#sudoku.consolesolver.ConsoleTrigger","title":"<code>ConsoleTrigger</code>","text":"<p>         Bases: <code>NoTrigger</code></p> <p>Trigger that requires the user to press 'enter' to show the next solving step.</p>"},{"location":"api/sudoku/consolesolver/#sudoku.consolesolver.solve","title":"<code>solve(sudoku, stepping, flush=False)</code>","text":"<p>Solve a Sudoku given as <code>Sudoku</code> object (possibly obtained by the <code>load</code> function). Use the <code>stepping</code> parameter to choose between the steppers  'any', to render every solving step, 'skip' to completely suppress  rendering, or 'interesting' to only print more elaborate solving methods.  Use the <code>flush</code> parameter to erase the rendered output of the previous  solving step before continuing.</p> <p>Parameters:</p> Name Type Description Default <code>sudoku</code> <code>Sudoku</code> <p>The puzzle to solve</p> required <code>stepping</code> <code>str</code> <p>Specify what solving steps to render</p> required <code>flush</code> <code>bool</code> <p>Set to <code>True</code> to erase the previous solving step</p> <code>False</code> <p>Returns:</p> Type Description <code>Sudoku</code> <p>The solved puzzle</p>"},{"location":"api/sudoku/formatting/","title":"formatting","text":"<p>This module provides the base class for <code>Formatter</code> objects.</p>"},{"location":"api/sudoku/formatting/#sudoku.formatting.BlankFormatter","title":"<code>BlankFormatter</code>","text":"<p>Formatters implement the <code>render</code> method called by any stepper to print the progress of the solver to the screen by any means.</p>"},{"location":"api/sudoku/formatting/#sudoku.formatting.BlankFormatter.render","title":"<code>render(sudoku, considered_tiles=None, considered_options=None, affected_tiles=None, affected_options=None, solving_step=0, solving_message=None)</code>  <code>abstractmethod</code>","text":"<p>Print the Sudoku to the screen by the mean of your desire</p>"},{"location":"api/sudoku/formatting/#sudoku.formatting.DeadFormatter","title":"<code>DeadFormatter</code>","text":"<p>         Bases: <code>BlankFormatter</code></p> <p>Trivial formatter to raise an error when its <code>render</code> method is called. Such objects serve as default value for variables that take an object of  type <code>BlankFormatter</code> as value.</p>"},{"location":"api/sudoku/formatting/#sudoku.formatting.FormatterMissingError","title":"<code>FormatterMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No formatter has been assigned to the stepper.</p>"},{"location":"api/sudoku/solvertools/","title":"solvertools","text":"<p>Module providing the core tools to build and interact with a Sudoku solver.</p>"},{"location":"api/sudoku/solvertools/#sudoku.solvertools.generate_solver","title":"<code>generate_solver(method_order, stepper)</code>","text":"<p>Build a Sudoku solver by deciding in what order the solving methods (i.e. the instances of <code>FmtSolvingMethod</code> classes) are chained together. The  order of the <code>method_order</code> array implies that after the failure of the  n-th method, the n+1-th method will be used. On the other hand, at success of the n-th method, the solver will proceed by calling the 1st element of <code>method_order</code>. Moreover, any <code>StepperBase</code> object must be provided to guide the user through the solving process.</p> <p>Parameters:</p> Name Type Description Default <code>method_order</code> <code>Tuple[FmtSolvingMethod]</code> <p>Solving Algorithm objects in their preferred order</p> required <code>stepper</code> <code>StepperBase</code> <p>the Stepping object used by the </p> required <p>Returns:</p> Type Description <code>FmtSolvingMethod</code> <p>The Solver</p>"},{"location":"api/sudoku/solvertools/#sudoku.solvertools.load","title":"<code>load(path)</code>","text":"<p>Load a Sudoku puzzle stored as <code>csv</code> file at <code>path</code> and build a <code>Sudoku</code> structure form the tow-dimensional grid.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>the path to the <code>.csv</code> file</p> required <p>Returns:</p> Type Description <code>Sudoku</code> <p>The Puzzle in its initial shape</p>"},{"location":"api/sudoku/solvertools/#sudoku.solvertools.save","title":"<code>save(sudoku, path)</code>","text":"<p>Write the solved <code>sudoku</code> puzzle to a <code>csv</code> file at <code>path</code></p> <p>Parameters:</p> Name Type Description Default <code>sudoku</code> <code>Sudoku</code> <p>the puzzle to save</p> required <code>path</code> <code>Path</code> <p><code>.csv</code> file to write to</p> required"},{"location":"api/sudoku/solvingmethods/","title":"solvingmethods","text":"<p>Core module of the solver, providing the structure of the different solving algorithms by means of the base classes <code>FmtSolvingBase</code> and  <code>FmtSolvingMethod</code>. These classes work as templates for the integration of the specific solving algorithms through their child classes but also provide  the abstract interface to access these algorithms. </p> <p>Use this module to integrate your own solving algorithms to this solver or to access the four default solving methods: <code>NTilesNOptions</code>, <code>ScaledXWing</code>,  <code>YWing</code> and <code>Bifurcation</code>.</p> <p>Moreover, this file also provides the device required to remove candidates from  Sudoku tiles. Observe that the implemented algorithms are not able to solve the  puzzle on their own but depend on a prescription of what algorithm to use in the  specific state of the puzzle. This logic is implemented by means of any  solving-method class having attributes that link to other solving-method classes which are to be used depending on the success or failure of the present solving  algorithm. The linking of the solving methods is done via the <code>generate_solver</code>  function found in <code>solver.py</code></p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.Bifurcation","title":"<code>Bifurcation</code>","text":"<p>         Bases: <code>FmtSolvingMethod</code></p> <p>The uninspired emergency solving method.</p> <p>After failure of the previous algorithms, we may still fall back to a trial and error approach by considering tiles with two candidates left and by mindlessly picking one of them as the tiles value. From there on, we can  continue solving the puzzle with the 'more analytic' methods until we  either solve to puzzle or run into a violation of the Sudoku rules. Since we only apply this approach to 'two-candidate' tiles, a failure of the try still immediately fixes the definitive value of the considered tile.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtParamSolvingMethod","title":"<code>FmtParamSolvingMethod</code>","text":"<p>         Bases: <code>FmtSolvingMethod</code></p> <p>Base class for solving methods that depend on a parameter. The minimum value the parameter takes is specified by the <code>_N_MIN</code> class variable which varies between the different solving method classes that inherit from the present class. </p> <p>The solving method's parameter is set at initialization of any such object;  if the given parameter is smaller than <code>_N_MIN</code>, a corresponding error terminates the program.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingBase","title":"<code>FmtSolvingBase</code>","text":"<p>Class to define the basic structure of any object the Sudoku solver  consists of. Such child classes must always implement a <code>launch</code> method  which, in the case of the <code>RemoveAndUpdate</code> class, invokes the removal  process whereas in the case of any regular solving method (i.e. of any  class inheriting from <code>FmtSolvingMethod</code>), the respective solving algorithm will be invoked.</p> <p>Any such class has a <code>_stepper</code> attribute which is the tool needed to guide the user through the solving process and to collect information thereof.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingBase.launch","title":"<code>launch(S, *args)</code>  <code>abstractmethod</code>","text":"<p>Interface method to invoke the internals of the corresponding solving algorithm.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingMethod","title":"<code>FmtSolvingMethod</code>","text":"<p>         Bases: <code>FmtSolvingBase</code></p> <p>Base class to define the structure of the solver. </p> <p>Any class inheriting from this base represents an algorithm used to  eliminate candidate options from the unsolved puzzle. </p> <p>The implementation of these algorithms happens by means of overloading the  abstract <code>launch</code> method. This method, taking the unsolved puzzle as  argument, executes the corresponding solving algorithm and depending on  its success decides what solving method to try next. That is, if the present algorithm succeeds at eliminating at least one candidate option, then the  <code>launch</code> method of the <code>_advance</code> attribute is invoked. On the other hand,  if the present algorithm fails at removing candidates, the unsolved puzzle  is passed to the <code>launch</code> implementation of the <code>_fall_back</code> attribute. Both, the <code>_advance</code> and the <code>_fall_back</code> object must therefore be an  instances of a children of <code>FmtSolvingMethod</code> themselves.</p> <p>If none of the implemented solving methods (i.e. non of the instances of the corresponding children of <code>FmtSolvingMethod</code>) manage to contribute to  the solution, the puzzle must be considered unsolvable. Therefore, the  <code>_fall_back</code> attribute defaults to <code>_SolvingFail()</code> which is a trivial  child of <code>FmtSolvingMethod</code> whose <code>launch</code> method raises an error. Hence, if  any solving-method object does not explicitly link a <code>_fall_back</code> instance, it is automatically considered to represent the worst case algorithm to be  tried as its failure implies the insolubility of the puzzle by this solver.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingMethod.launch","title":"<code>launch(S)</code>  <code>abstractmethod</code>","text":"<p>Interface method to invoke the internals of the Solving Algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>Sudoku</code> <p>the Sudoku puzzle to which the algorithm is applied</p> required"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.NTilesNOptions","title":"<code>NTilesNOptions</code>","text":"<p>         Bases: <code>FmtParamSolvingMethod</code></p> <p>A solving method that checks if a set of the same <code>n</code> options is found <code>n</code> times in the same row, column or square. If, e.g., the set of candidate options <code>{1,2}</code> is found twice in the same row, i.e., if two separate tiles have the exact same two candidates left, no other tile in the same row may take any of the latter two values.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.RemoveAndUpdate","title":"<code>RemoveAndUpdate</code>","text":"<p>         Bases: <code>FmtSolvingBase</code></p> <p>Special solving-method class whose <code>launch</code> method implements the  functionality to remove candidates from specified tiles.  Correspondingly, this method should be invoked by the 'regular'  solving-method objects, i.e., by instances of classes that inherit from  <code>FmtSolvingMethod</code>.</p> <p>Moreover, the removal process also triggers the clean up methods <code>_single_occurrence_of_option</code> and <code>_remove_option_from_neighbors</code> which implement further candidate removal steps that are directly implied by the initial removal.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.RemoveAndUpdate.launch","title":"<code>launch(S, where, which)</code>","text":"<p>Interface to initiate the removal of the candidates <code>which</code> form the  tile at <code>where</code> of the Sudoku <code>S</code>.</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>Sudoku</code> <p>the puzzle</p> required <code>where</code> <code>int</code> <p>index of the concerned tile</p> required <code>which</code> <code>set</code> <p>candidates to be removed</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Could any candidates be removed?</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.RemoverMissingError","title":"<code>RemoverMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No remover has been assigned to the solving method.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.ScaledXWing","title":"<code>ScaledXWing</code>","text":"<p>         Bases: <code>FmtParamSolvingMethod</code></p> <p>Solving methods that searches for candidate options appearing in an  <code>n</code> x <code>n</code> square. </p> <p>Consider, e.g., two columns in which the same candidate occurs at exactly  two positions. Now, let the rows in which these occurrences are to be the same  for both columns. Then non of the remaining tiles within the latter tow rows  can take this candidate as value anymore as its position is already fixed to a place in either of the tow columns we considered initially.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.SolverError","title":"<code>SolverError</code>","text":"<p>         Bases: <code>RuntimeError</code></p> <p>The puzzle can't be solved with the given solver.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.StepperMissingError","title":"<code>StepperMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No stepper has been assigned to the solving method.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.YWing","title":"<code>YWing</code>","text":"<p>         Bases: <code>FmtSolvingMethod</code></p> <p>Implementation of the classical 'Y-Wing' strategy.</p> <p>This methods first searches for an 'anchor' tile, i.e., a tile with two candidates left, say <code>{1,2}</code>. From this tile on, the neighboring row, column and square are searched for further 'two-candidate' tiles. The aim, thereby, is to find two more tiles, one of them including <code>1</code> and the other <code>2</code> as  candidate. Most importantly these two tiles must also have one common candidate, say <code>3</code>, such that we end up with two 'node' tiles related to the anchor, having candidates <code>{1,3}</code> and <code>{2,3}</code>. No matter what configuration  eventually solves the puzzle, one of the node tiles must be assigned the value <code>3</code> as fixing the value of one node immediately fixes the value of the other node via the anchor tile. Consequently, <code>3</code> can  be excluded as candidate from any tile that is simultaneously related to  both nodes.</p>"},{"location":"api/sudoku/stepping/","title":"stepping","text":"<p>This module provides the base for any 'stepper' class plus a few example steppers used in the default solver. The steppers are devices used as backend  for the formatted output of the solving process. Stepper objects provide an  interface for the solving method classes to pass information about any  successfully eliminated candidate. Moreover, they are able to pause the solving process after any successful elimination to pass the latter information to any frontend, thus enabling the user to step through the solving process, possibly by means of a graphical output.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.AnyStep","title":"<code>AnyStep</code>","text":"<p>         Bases: <code>StepperBase</code></p> <p>Stepper class to transfer information about every elimination step to the frontend.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.AnyStep.show_step","title":"<code>show_step(sudoku, affected_tiles, affected_options)</code>","text":"<p>Invoke the render to print the solving step based on the previously specified consideration.</p> <p>Parameters:</p> Name Type Description Default <code>sudoku</code> <code>Sudoku</code> <p>the concerned puzzle</p> required <code>affected_tiles</code> <code>set</code> <p>the tiles affected by the present configuration             of the neighboring tiles</p> required <code>affected_options</code> <code>set</code> <p>the candidate to be removed from the latter tiles</p> required"},{"location":"api/sudoku/stepping/#sudoku.stepping.DeadStepper","title":"<code>DeadStepper</code>","text":"<p>         Bases: <code>StepperBase</code></p> <p>Trivial 'stepper' class serving as default value for any variable whose value must be of type <code>StepperBase</code>. That is, if no proper 'stepper' is assigned, this placeholder will raise an error whenever the user tries to  make use of the abstract methods that any stepper needs to implement.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.DeadTrigger","title":"<code>DeadTrigger</code>","text":"<p>         Bases: <code>NoTrigger</code></p> <p>Trivial trigger to raise an error when called. Such objects serve as  default argument for variables that take an object of type <code>NoTrigger</code> as value.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.InterestingStep","title":"<code>InterestingStep</code>","text":"<p>         Bases: <code>AnyStep</code></p> <p>Stepper with functionality analogous to <code>AnyStep</code> but only solving steps whose importance was set to 'interesting' by means of the respective  argument of the <code>set_consideration</code> method are rendered.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.NoTrigger","title":"<code>NoTrigger</code>","text":"<p>Classes that implement the functionality to await any sort uf user input after the puzzle has been rendered.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.NoTrigger.trigger_next_step","title":"<code>trigger_next_step()</code>","text":"<p>Trigger the next solving step.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.Skipper","title":"<code>Skipper</code>","text":"<p>         Bases: <code>StepperBase</code></p> <p>Trivial stepper class that only counts the solving steps without invoking any rendering or interrupting the solving process.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase","title":"<code>StepperBase</code>","text":"<p>Base class providing the template for any stepper by implementing a  solution-step counting mechanism and the interface to pass information about the current state of the puzzle through the stepper to the frontend.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.__init__","title":"<code>__init__(formatter=None, trigger=None)</code>","text":"<p>Create a stepper instance by passing a formatting function, i.e. a function to render the puzzle with additional information about the solving process</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.set_consideration","title":"<code>set_consideration(tiles, options, message, interesting=False)</code>  <code>abstractmethod</code>","text":"<p>Tell the stepper what <code>options</code> of what <code>tiles</code> we're currently  considering to draw conclusions about what candidates we can eliminate. The <code>message</code> will be printed at a successful elimination. The <code>interesting</code> parameter specifies the complexity of the consideration. </p> <p>Parameters:</p> Name Type Description Default <code>tiles</code> <code>set</code> <p>the tiles we consider to draw conclusion about possible  future removals of candidates of neighboring tiles</p> required <code>options</code> <code>set</code> <p>the candidates that allow for the latter conclusions</p> required <code>message</code> <code>str</code> <p>the message to pass to the render when successfully  removing candidates based on the latter conclusion. interesting: whether the removal step should be printed by a  stepper that only cares about elaborate algorithms</p> required"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.show","title":"<code>show(sudoku)</code>","text":"<p>Use the selected formatter to render the Sudoku without any information about the solving process.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.show_step","title":"<code>show_step(*args)</code>  <code>abstractmethod</code>","text":"<p>Invoke the frontend to print the current state of the Sudoku and  increase the solving step <code>counter</code> by one as this method is only called after a successful elimination of a candidate.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperMissingError","title":"<code>StepperMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No stepper has been assigned to the solving method.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.TriggerMissingError","title":"<code>TriggerMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No trigger has been assigned to the stepper.</p>"},{"location":"api/sudoku/structure/","title":"structure","text":"<p>This module provides the two classes <code>Tile</code> and <code>Sudoku</code> that serve as base structure for the solver to operate on. Observe that the abbreviations 'r', 'c' and 's' for row, column and square, stored in <code>CONTAINER_TYPES</code>, are used throughout this program. Square, thereby, refers to typical 3x3 tile  collections.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku","title":"<code>Sudoku</code>","text":"<p>Container structure to represent the Sudoku grid by storing 81 <code>Tile</code>  objects in a one dimensional list.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.containers","title":"<code>containers: Dict[str, List[List[int]]]</code>  <code>property</code>","text":"<p>Structure to store the indices of the tiles, i.e. their position in the <code>tiles</code> array, that live in each row, column and square. </p> <p>Consider the following example to retrieve the array positions of the  tiles that live in the first square:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Sudoku.containers['s'][0]\n[0, 1, 2, 9, 10, 11, 18, 19, 20]\n</code></pre> <p>Thereby, the subscript <code>['s'][0]</code> indicates the square at position 0.</p> <p>Returns:</p> Type Description <code>Dict[str, List[List[int]]]</code> <p>The containers (as described above)</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.done","title":"<code>done: bool</code>  <code>property</code>","text":"<p>Returns:      Whether the puzzle is solved</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.max_options","title":"<code>max_options: int</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The maximum number of candidates over all the tiles</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.occurrences","title":"<code>occurrences: Dict[str, List[List[Set[int]]]]</code>  <code>property</code>","text":"<p>For each row, column and square and for each number of 1 to 9, this  dictionary stores at which <code>tiles</code> positions the respective value still  appears as candidate.</p> <p>Consider the following example to retrieve the set of array positions at  which the candidate <code>9</code> is still found in the second row:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Sudoku.occurrences['r'][1][8]\n{9, 11, 15}\n</code></pre> <p>Thereby, <code>['r'][1]</code> indicates the second row and <code>[8]</code> specifies the  list position at which the occurrences of the value <code>9</code> are stored.</p> <p>Returns:</p> Type Description <code>Dict[str, List[List[Set[int]]]]</code> <p>The occurrences (as above duh xD)</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.tiles","title":"<code>tiles: List[Tile]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>List[Tile]</code> <p>List of length 81 to store every tile of the Sudoku grid.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_complexity_map","title":"<code>get_complexity_map()</code>","text":"<p>Returns:      The solving step a which the definite solution has been found      for each tile (organized row by row).</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_options","title":"<code>get_options()</code>","text":"<p>Returns:</p> Type Description <code>List[List[set]]</code> <p>The remaining candidates for each tile as set organized row by row</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_solved","title":"<code>get_solved()</code>","text":"<p>Returns:      The solved puzzle as a two-dimensional list.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_tiles","title":"<code>get_tiles()</code>","text":"<p>Returns:</p> Type Description <code>List[List[Tile]]</code> <p>The tiles organized row by row</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.is_valid","title":"<code>is_valid()</code>","text":"<p>Explicitly check whether the Sudoku rules have been violated in the  solving process. One should try to avoid explicit use of this method as the implementations of the solving algorithms should automatically  detect if such a violation has been taken place and correspondingly set  the <code>violated</code> attribute to <code>True</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Is the present configuration valid?</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile","title":"<code>Tile</code>","text":"<p>Structure to represent a tile of the Sudoku grid. Tile objects store the  position of a tile by means of specifying their row, column and square  index. Moreover, this class is needed to keep track of the possible  candidate values a tile can still take in the process of solving the puzzle.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile.options","title":"<code>options: set</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>set</code> <p>The remaining candidate values for this tile</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile.pos","title":"<code>pos: Dict[str, int]</code>  <code>property</code>","text":"<p>Get the row, column and square index of the tile formatted as <code>{'r': *row index*, 'c': *column index*, 's': *square index*}</code>.</p> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>The row, column and square index of the tile</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile.to_none_tile","title":"<code>to_none_tile(tile)</code>  <code>classmethod</code>","text":"<p>Create a tile that has no candidate values at the position of the  <code>tile</code> that is given as argument.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.index_to_pos","title":"<code>index_to_pos(t)</code>","text":"<p>Get the row, column and square index from the tile index <code>t</code> formatted as  <code>{'r': *row index*, 'c': *column index*, 's': *square index*}</code>.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>int</code> <p>the tile index</p> required <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict containing row, column and square index</p>"},{"location":"api/sudoku/structure/#sudoku.structure.row_column_to_index","title":"<code>row_column_to_index(r, c)</code>","text":"<p>Get the tile index, i.e. the position of the tile in an array of dimension <code>81</code>, by specifying the row <code>r</code> and the column <code>c</code>.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>row index</p> required <code>c</code> <code>int</code> <p>column index</p> required <p>Returns:</p> Type Description <code>int</code> <p>tile index</p>"}]}