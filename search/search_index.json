{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sudokumentation","text":""},{"location":"#welcome-to-the-documentation-of-the-sudoku2-package","title":"Welcome to the documentation of the sudoku2 package!","text":"<p>Info</p> <p>The semester break is over which means that the development of this package (and its documentation) will be slowed down immensely.</p> <p>These docs shall give you an overview of the possible applications of my Sudoku package; On the one hand, the built in solver can be used to guide you step-by-step to the solution of a Sudoku puzzle. On the other hand, the package provides an API which lets you easily extend the capabilities of the basic solver by adding custom solving algorithms or by implementing any arbitrary Python frontend to render the individual solving steps. </p> <p>Warning</p> <p>Even the core functionality of the Package is still in development. Both the API and the features that are abstracted by it may still change heavily. Proceed with caution if you intend to integrate this package in your own project. Moreover, if you are reading this from a development branch, the docs may not exactly correspond to the present state of the code.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the library, clone its source code from GitHub and install it to your Python environment using <code>pip</code>.</p> <pre><code>$ git clone https://github.com/wyssard/sudoku2.git\n$ pip install ./sudoku2\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Info</p> <p>For any usage of the package that goes beyond the Standard Solver, it's strongly recommended to start the journey through these docs with the description of the Solving Process. </p> <p>If you intend to use the package as a stand-alone tool to solve Sudoku puzzles, please refer to:</p> <ul> <li>Standard Solver - simple functional access to the pre-built solver</li> <li>Custom Solver - create a custom solver by explicitly deciding what solving algorithms to use and what solving steps to render</li> </ul> <p>If you're interested in modifying the basic capabilities or to use the solver backend in your own project, refer to: </p> <ul> <li>API Guide - walks you through the steps to extend the default behavior</li> <li>API Reference - documentation of the public API</li> </ul>"},{"location":"api_guide/","title":"API Guide","text":"<p>This guide walks you through the creation of solving method, stepper and formatting classes. The respective instances can then be composed to a solver object by following the procedure illustrated in the Custom Solver section. Make sure to consider the latter section first before continuing with this guide.</p> <p>The creation of the solving method, stepper and formatting classes is thereby illustrated by reproducing classes that are already integral part of this package. To avoid duplicate code, there's no example code for the largest part of this guide. We only provide a small snippet to illustrate the usage of the classes you are to create thereinafter.</p>"},{"location":"api_guide/#solving-methods","title":"Solving Methods","text":"<p>Let us begin by reimplementing the most basic of all solving methods. </p>"},{"location":"api_guide/#steppers","title":"Steppers","text":""},{"location":"api_guide/#formatters","title":"Formatters","text":""},{"location":"api_guide/#assembly","title":"Assembly","text":""},{"location":"custom_solver/","title":"Create a Custom Solver","text":"<p>Did you ever get bored of the solving algorithms used by the default solver or wanted to print the solving steps using a more interesting frontend than the console? </p> <p>No worries, the solution to your problem is already at hand. This guide will show you how to build your own solver by assembling a solver similar to the standard configuration. Understanding how such a solver is put together will bring you into the position to implement your own behavior and inject it into a solver object. </p> <p>Tip</p> <p>In a nutshell, the API Guide explains how to extend the basic capabilities with new behavior by means of inheritance whereas this guide shows you how your custom objects are eventually composed to a solver. You can find the source code for this guide under <code>examples/doc_reference</code> in the source repository. To get the expected behavior, make sure that you set <code>doc_reference</code> as your working directory.</p>"},{"location":"custom_solver/#the-generate_solver-function","title":"The <code>generate_solver</code> Function","text":"<p>The assembly of a solver happens by means of the <code>generate_solver</code> function which can be imported directly form the <code>sudoku</code> parent package:</p> <pre><code>from sudoku import generate_solver\n</code></pre>"},{"location":"custom_solver/#solving-algorithms","title":"Solving Algorithms","text":"<p>Considering its documentation, we see that this function first of all required a list of solving algorithms. As you will see in the API Guide, solving algorithms are objects inheriting from <code>FmtSolvingMethod</code>. Instead of creating new algorithms, let us import a few of the prebuilt objects from <code>sudoku</code>:</p> <pre><code>from sudoku import ScaledXWing, YWing, Bifurcation\n</code></pre> <p>Note</p> <p>Since my naming is not yet fully consistent with the established algorithm names, I recommend considering the documentations of the respective solving methods.</p>"},{"location":"custom_solver/#stepping","title":"Stepping","text":"<p>When going on to the second argument of <code>generate_solver</code>, we see that a so-called <code>stepper</code> is required. Before adding such a <code>StepperBase</code> object to our collection of solving methods, let me explain its purpose: </p> <p>As you can see in the Flowchart, a rendering step is triggered after successful elimination of a candidate and the program awaits a certain signal before continuing. In this whole process, the stepper works a an intermediate object that stores the information about the solving step and that decides whether to trigger the rendering process. That is, depending on the stepper object used, certain solving steps may or may not be printed. In order for such a stepper to work, it needs to know what rendering frontend to use and what signal to await to let the solver continue its work after rendering. Thereby the rendering frontend is an object inheriting from <code>BlankFormatter</code> while the trigger to continue to solving process is represented by an object based on <code>NoTrigger</code>.</p> <p>For this example, let us import the <code>InterestingStep</code> stepper, which omits rendering certain solving steps based on trivial considerations. </p> <pre><code>from sudoku import InterestingStep\n</code></pre> <p>Since we want to reproduce the standard solver, we must tell the stepper to use the console as frontend and to listen for the Enter key to be pressed to resume. The respective classes are given by:</p> <pre><code>from sudoku import ConsoleFormatting, ConsoleTrigger\n</code></pre> <p>and the stepper is constructed via:</p> <pre><code>stepper = InterestingStep(ConsoleFormatter(), ConsoleTrigger())\n</code></pre>"},{"location":"custom_solver/#assembly","title":"Assembly","text":"<p>Now, we finally have all the required objects at hand to build the solver. When passing the solving algorithms to <code>generate_solver</code>, its important to understand the implications of the list's order: As you can see in the Flowchart, depending on the success of a solving method, the program decides what algorithm to proceed with. Thereby, the <code>n+1</code> element of the list of algorithms is automatically considered to be the fallback of the element at position <code>n</code>. Success of an algorithm, on the other hand, implies that the solver will continue with the element a position <code>0</code>, preferably the most basic algorithm. Failure of the last element will terminate the program as the solver is unable to make any further progress.</p> <pre><code>solver = generate_solver([ScaledXWing(2), YWing(), Bifurcation()], stepper)\n</code></pre> <p>And there you go, try to solve the example puzzle from the previous guide by:</p> <pre><code>from sudoku import load\nsolved = solver.launch(load(\"example.csv\"))\n</code></pre>"},{"location":"custom_solver/#sum-up","title":"Sum Up","text":"<p>The whole program can now compactly be written as:</p> <pre><code>from sudoku import generate_solver, ScaledXWing, YWing, Bifurcation, InterestingStep, ConsoleFormatter, ConsoleTrigger, load\nsolver = generate_solver(\n    [ScaledXWing(2), YWing(), Bifurcation()],\n    InterestingStep(ConsoleFormatter(), ConsoleTrigger())\n)\nsolved = solver.launch(load(\"example.csv\"))\n</code></pre> <p>Info</p> <p>A similar example with a little extra (graphical output using matplotlib) can be found in the source repository under <code>examples/std_examples</code>.</p> <p>Follow the API Guide to implement your own solving algorithms, steppers and formatters.</p>"},{"location":"solving_process/","title":"Solving Process","text":"<p>When working with the Custom Solver or when making use of the API, your interaction with the package goes beyond the simplified functional access and you will be confronted with the objects that, e.g., represent the solving algorithms or the rendering frontend. In order to understand how these objects interact with each other, a basic understanding of the solving procedure, illustrated by the flowchart below, is indispensible.</p> <p>We come back to some specific nodes of the diagram when discussing the API or the Custom Solver generator.</p>"},{"location":"solving_process/#flowchart","title":"Flowchart","text":"<pre><code>flowchart\n    init([Launch Solver]) --&gt; InitialAlgorithm[Use initial Algorithm]\n    InitialAlgorithm --&gt; LaunchSolver[Launch Algorithm] \n    LaunchSolver --&gt; Solved{Puzzle \\nsolved?}\n\n    Solved --Yes--&gt; Return([Return Solved Puzzle])\n\n    Solved --No---&gt; SolverLoop[Loop over Tiles]\n    SolverLoop --&gt; Increase[Next Tile]\n    Increase --&gt; TerminateLoop{Last \\nitem?}\n\n    TerminateLoop --Yes--&gt; CheckSuccess{Algorithm \\ncould remove \\nat least one\\n candidate?}\n\n    CheckSuccess --No---&gt; FallbackLeft{Fallback \\nAlgorithm \\nspecified?}\n    FallbackLeft --Yes--&gt; Fallback[Continue with Fallback Algorithm]\n\n    CheckSuccess --Yes--&gt; Advance[Continue with less elaborate Algorithm]\n    Fallback &amp; Advance --&gt; LaunchSolver\n\n    FallbackLeft --No--&gt; Fail([Can't solve puzzle])\n\n    TerminateLoop --No--&gt; FindPattern[[Search for Pattern on the Sudoku grid \\nthat lets us deduce \\nwhat Candidates we can remove \\nfrom neighboring Tiles]]\n    FindPattern --&gt; PatternFound{Pattern \\nmatched?}\n\n    PatternFound --No--&gt; Increase\n\n    PatternFound --Yes--&gt; TryRemove[Check if there are any Candidates \\nconcerned by the Pattern]\n    TryRemove --&gt; ToRemove{Concerned\\ncandidates\\nfound?}\n\n    ToRemove --No--&gt; Increase\n\n    ToRemove --yes--&gt; Remove[Remove Candidates]\n    Remove --&gt; Render{{Render Solving Step}}\n    Render --&gt; Trigger[Trigger Next Step]\n    Trigger --&gt; CleanUp[[Update Routine involving very basic Solving Algorithms]]\n    CleanUp --&gt; Increase\n</code></pre>"},{"location":"solving_process/#a-word-of-caution","title":"A Word of Caution","text":"<p>Since there are some severe differences in between the implemented solving algorithms, the API does not force you (so far) to entirely stick to the prescription suggested by the diagram. For example, you are free to decide whether to implement a loop over tiles or to replace it by a better suiting approach.</p> <p>Note</p> <p>Future versions may address this inconvenience by providing further abstraction that ultimately forces you to stick to the suggested prescription by means of an intermediate abstract class. Since, however, the procedures that are not yet abstracted are very simple (they come in form of simple conditions or loops), further abstraction may also be omitted completely, to make the code more readable.</p>"},{"location":"standard_solver/","title":"Using the Standard Solver","text":"<p>Info</p> <p>You can find the code of this guide under <code>examples/doc_reference</code> in the source repository. Make sure so set <code>doc_reference</code> as working directory to get the expected behavior.</p> <p>After having installed the package to your environment, the pre-constructed solver can be easily accessed in a functional way by means of the functions <code>load</code>, <code>solve</code> and <code>save</code>. Begin by importing the respective functions from <code>sudoku</code>:</p> <pre><code>from sudoku import load, solve, save\n</code></pre>"},{"location":"standard_solver/#load","title":"Load","text":"<p>Use the <code>load</code> function to create and return a <code>Sudoku</code> object from the unsolved puzzle. The puzzle must be stored as <code>csv</code> file whose entries represent the initial configuration of the Sudoku grid. Any unspecified tiles take the value <code>0</code> as placeholder. Let's, e.g., consider the puzzle represented by the content of <code>example.csv</code> (the file should be stored in your working directory). </p> example.csv<pre><code>0, 0, 1, 0, 0, 4, 0, 8, 0\n0, 0, 5, 0, 0, 0, 0, 0, 7\n4, 7, 0, 0, 3, 0, 0, 6, 0\n6, 4, 0, 0, 0, 8, 0, 0, 9\n1, 0, 0, 0, 0, 0, 0, 0, 0\n0, 0, 0, 0, 5, 0, 8, 0, 0\n0, 0, 0, 2, 0, 0, 0, 3, 0\n0, 0, 7, 0, 0, 0, 0, 0, 0\n8, 9, 0, 0, 0, 5, 0, 0, 6\n</code></pre> <p>Load it into a <code>Sudoku</code> structure by:</p> <pre><code>s = load(\"example.csv\")\n</code></pre>"},{"location":"standard_solver/#solve","title":"Solve","text":"<p>Invoke the solving process by passing the <code>Sudoku</code> object to the <code>solve</code> function. Before returning the solved puzzle, the solver will guide you through the solving process by printing some of the solving steps to the console (including the final result). A solving step, thereby, refers to any operation that lets us exclude one of the remaining candidates of an 'unsolved' tile.</p> <p>Use the second argument of the solve function to decide what solving steps to print. Refer to the documentation of <code>solve</code> to see what options are available. In this example, we will only print some less trivial steps by passing <code>\"interesting\"</code> as argument. Moreover, for the purpose of this guide, we're using ASCII characters to format the output by setting the <code>unicode</code> keyword to <code>False</code>.</p> <pre><code>solved = solve(s, \"interesting\", unicode=False)\n</code></pre> <p>The console output contains the present state of the puzzle as well as information about the conclusions made to remove certain candidates in the shown step. Observe that both the affected candidates (i.e. those we are to remove) and those we considered to draw conclusions are highlighted by means of ANSI escape codes. Rendering thus depends on the console you're using. A typical output (without highlighting the considered candidates) could look like:</p> <pre><code>solving step 410: tile 16 is the only tile in column 7 with 4 as option\nstatus: ok\n+-----------------------+-----------------------+-----------------------+\n| [9]    [6]    [1]     | [5]    [7]    [4]     | [3]    [8]    [2]     |\n| [3]    [8]    [5]     | [6,9]  [6,9]  [2]     | [1,4]  [1,4,9][7]     |\n| [4]    [7]    [2]     | [8]    [3]    [1]     | [9]    [6]    [5]     |\n+-----------------------+-----------------------+-----------------------+\n| [6]    [4]    [3]     | [1]    [2]    [8]     | [5,7]  [5,7]  [9]     |\n| [1]    [5]    [8]     | [7]    [4]    [9]     | [6]    [2]    [3]     |\n| [7]    [2]    [9]     | [6]    [5]    [3]     | [8]    [1]    [4]     |\n+-----------------------+-----------------------+-----------------------+\n| [5]    [1]    [6]     | [2]    [9]    [7]     | [4]    [3]    [8]     |\n| [2]    [3]    [7]     | [4]    [8]    [6]     | [5]    [9]    [1]     |\n| [8]    [9]    [4]     | [3]    [1]    [5]     | [2]    [7]    [6]     |\n+-----------------------+-----------------------+-----------------------+\n\nnext step: (press ENTER)\n</code></pre> <p>Eventually, the solved puzzle is rendered to the console once more before the <code>solve</code> function returns.</p> <pre><code>solving step 415: puzzle solved\nstatus: ok\n+-----------+-----------+-----------+\n| [9][6][1] | [5][7][4] | [3][8][2] |\n| [3][8][5] | [9][6][2] | [1][4][7] |\n| [4][7][2] | [8][3][1] | [9][6][5] |\n+-----------+-----------+-----------+\n| [6][4][3] | [1][2][8] | [7][5][9] |\n| [1][5][8] | [7][4][9] | [6][2][3] |\n| [7][2][9] | [6][5][3] | [8][1][4] |\n+-----------+-----------+-----------+\n| [5][1][6] | [2][9][7] | [4][3][8] |\n| [2][3][7] | [4][8][6] | [5][9][1] |\n| [8][9][4] | [3][1][5] | [2][7][6] |\n+-----------+-----------+-----------+\n</code></pre>"},{"location":"standard_solver/#save","title":"Save","text":"<p>You may then want to write the solved puzzle to a file named, e.g., <code>solved.csv</code> by using the <code>save</code> function:</p> <pre><code>save(solved, \"solved.csv\")\n</code></pre> solved.csv<pre><code>9,6,1,5,7,4,3,8,2\n3,8,5,9,6,2,1,4,7\n4,7,2,8,3,1,9,6,5\n6,4,3,1,2,8,7,5,9\n1,5,8,7,4,9,6,2,3\n7,2,9,6,5,3,8,1,4\n5,1,6,2,9,7,4,3,8\n2,3,7,4,8,6,5,9,1\n8,9,4,3,1,5,2,7,6\n</code></pre> <p>The whole program can now be compactly written as</p> <pre><code>from sudoku import load, solve, save\nsave(solve(load(\"example.csv\"), \"interesting\", unicode=False), \"solved.csv\")\n</code></pre> <p>Info</p> <p>Find a similar example in the source repository under <code>examples/std_examples</code>.</p>"},{"location":"api/modules/","title":"Modules","text":"<ul> <li>sudoku<ul> <li>consolesolver</li> <li>formatting</li> <li>solvertools</li> <li>solvingmethods</li> <li>stepping</li> <li>structure</li> </ul> </li> </ul>"},{"location":"api/sudoku/consolesolver/","title":"consolesolver","text":"<p>Example module to illustrate a coupling of the solver to the console as  frontend. Therefore, a corresponding <code>Trigger</code> and <code>Formatter</code> class must be implemented.</p>"},{"location":"api/sudoku/consolesolver/#sudoku.consolesolver.ConsoleFormatter","title":"<code>ConsoleFormatter</code>","text":"<p>         Bases: <code>BlankFormatter</code></p> <p>Basic formatter to print the solutions steps, i.e. the partially solved puzzle, to the console. Use the <code>flush</code> attribute to decide whether the  solution steps are stringed together in the console or if the previous step is consecutively removed.</p>"},{"location":"api/sudoku/consolesolver/#sudoku.consolesolver.ConsoleTrigger","title":"<code>ConsoleTrigger</code>","text":"<p>         Bases: <code>NoTrigger</code></p> <p>Trigger that requires the user to press 'enter' to show the next solving step.</p>"},{"location":"api/sudoku/consolesolver/#sudoku.consolesolver.solve","title":"<code>solve(sudoku, stepping, flush=False, unicode=True)</code>","text":"<p>Solve a Sudoku given as <code>Sudoku</code> object (possibly obtained by the <code>load</code> function). Use the <code>stepping</code> parameter to choose between the steppers  'any', to render every solving step, 'skip' to completely suppress  rendering, or 'interesting' to only print more elaborate solving methods.  Use the <code>flush</code> parameter to erase the rendered output of the previous  solving step before continuing.</p> <p>Parameters:</p> Name Type Description Default <code>sudoku</code> <code>Sudoku</code> <p>The puzzle to solve</p> required <code>stepping</code> <code>str</code> <p>Specify what solving steps to render</p> required <code>flush</code> <code>bool</code> <p>Set to <code>True</code> to erase the previous solving step</p> <code>False</code> <code>unicode</code> <code>bool</code> <p>Use Unicode box-drawing characters</p> <code>True</code> <p>Returns:</p> Type Description <code>Sudoku</code> <p>The solved puzzle</p>"},{"location":"api/sudoku/formatting/","title":"formatting","text":"<p>This module provides the base class for <code>Formatter</code> objects.</p>"},{"location":"api/sudoku/formatting/#sudoku.formatting.BlankFormatter","title":"<code>BlankFormatter</code>","text":"<p>Formatters implement the <code>render</code> method called by any stepper to print the progress of the solver to the screen by any means.</p>"},{"location":"api/sudoku/formatting/#sudoku.formatting.BlankFormatter.render","title":"<code>render(sudoku, considered_tiles=None, considered_options=None, affected_tiles=None, affected_options=None, solving_step=0, solving_message=None)</code>  <code>abstractmethod</code>","text":"<p>Print the Sudoku to the screen by the mean of your desire</p>"},{"location":"api/sudoku/formatting/#sudoku.formatting.DeadFormatter","title":"<code>DeadFormatter</code>","text":"<p>         Bases: <code>BlankFormatter</code></p> <p>Trivial formatter to raise an error when its <code>render</code> method is called. Such objects serve as default value for variables that take an object of  type <code>BlankFormatter</code> as value.</p>"},{"location":"api/sudoku/formatting/#sudoku.formatting.FormatterMissingError","title":"<code>FormatterMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No formatter has been assigned to the stepper.</p>"},{"location":"api/sudoku/solvertools/","title":"solvertools","text":"<p>Module providing the core tools to build and interact with a Sudoku solver.</p>"},{"location":"api/sudoku/solvertools/#sudoku.solvertools.generate_solver","title":"<code>generate_solver(method_order, stepper)</code>","text":"<p>Build a Sudoku solver by deciding in what order the solving methods (i.e. the instances of <code>FmtSolvingMethod</code> classes) are chained together. The  order of the <code>method_order</code> array implies that after the failure of the  n-th method, the n+1-th method will be used. On the other hand, at success of the n-th method, the solver will proceed by calling the 1st element of <code>method_order</code>. Moreover, any <code>StepperBase</code> object must be provided to guide the user through the solving process.</p> <p>Parameters:</p> Name Type Description Default <code>method_order</code> <code>Tuple[FmtSolvingMethod]</code> <p>Solving Algorithm objects in their preferred order</p> required <code>stepper</code> <code>StepperBase</code> <p>The Stepping object used by the Solver</p> required <p>Returns:</p> Type Description <code>FmtSolvingMethod</code> <p>The Solver</p>"},{"location":"api/sudoku/solvertools/#sudoku.solvertools.load","title":"<code>load(path)</code>","text":"<p>Load a Sudoku puzzle stored as <code>csv</code> file at <code>path</code> and build a <code>Sudoku</code> structure form the tow-dimensional grid.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the <code>.csv</code> file</p> required <p>Returns:</p> Type Description <code>Sudoku</code> <p>The Puzzle in its initial shape</p>"},{"location":"api/sudoku/solvertools/#sudoku.solvertools.save","title":"<code>save(sudoku, path)</code>","text":"<p>Write the solved <code>sudoku</code> puzzle to a <code>csv</code> file at <code>path</code></p> <p>Parameters:</p> Name Type Description Default <code>sudoku</code> <code>Sudoku</code> <p>The puzzle to save</p> required <code>path</code> <code>Path</code> <p><code>.csv</code> file to write to</p> required"},{"location":"api/sudoku/solvingmethods/","title":"solvingmethods","text":"<p>Core module of the solver, providing the structure of the different solving algorithms by means of the base classes <code>FmtSolvingBase</code> and  <code>FmtSolvingMethod</code>. These classes work as templates for the integration of the specific solving algorithms through their child classes but also provide  the abstract interface to access these algorithms. </p> <p>Use this module to integrate your own solving algorithms to this solver or to access the four default solving methods: <code>NTilesNOptions</code>, <code>ScaledXWing</code>,  <code>YWing</code> and <code>Bifurcation</code>.</p> <p>Moreover, this file also provides the device required to remove candidates from  Sudoku tiles. Observe that the implemented algorithms are not able to solve the  puzzle on their own but depend on a prescription of what algorithm to use in the  specific state of the puzzle. This logic is implemented by means of any  solving-method class having attributes that link to other solving-method classes which are to be used depending on the success or failure of the present solving  algorithm. The linking of the solving methods is done via the <code>generate_solver</code>  function found in <code>solver.py</code></p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.Bifurcation","title":"<code>Bifurcation</code>","text":"<p>         Bases: <code>FmtSolvingMethod</code></p> <p>The uninspired emergency solving method.</p> <p>After failure of the previous algorithms, we may still fall back to a trial and error approach by considering tiles with two candidates left and by mindlessly picking one of them as the tiles value. From there on, we can  continue solving the puzzle with the 'more analytic' methods until we  either solve to puzzle or run into a violation of the Sudoku rules. Since we only apply this approach to 'two-candidate' tiles, a failure of the try still immediately fixes the definitive value of the considered tile.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtParamSolvingMethod","title":"<code>FmtParamSolvingMethod</code>","text":"<p>         Bases: <code>FmtSolvingMethod</code></p> <p>Base class for solving methods that depend on a parameter. The minimum value the parameter takes is specified by the <code>_N_MIN</code> class variable which varies between the different solving method classes that inherit from the present class. </p> <p>The solving method's parameter is set at initialization of any such object;  if the given parameter is smaller than <code>_N_MIN</code>, a corresponding error terminates the program.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingBase","title":"<code>FmtSolvingBase</code>","text":"<p>Class to define the basic structure of any object the Sudoku solver  consists of. Such child classes must always implement a <code>launch</code> method  which, in the case of the <code>RemoveAndUpdate</code> class, invokes the removal  process whereas in the case of any regular solving method (i.e. of any  class inheriting from <code>FmtSolvingMethod</code>), the respective solving algorithm will be invoked.</p> <p>Any such class has a <code>_stepper</code> attribute which is the tool needed to guide the user through the solving process and to collect information thereof.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingBase.launch","title":"<code>launch(S, *args)</code>  <code>abstractmethod</code>","text":"<p>Interface method to invoke the internals of the corresponding solving algorithm.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingMethod","title":"<code>FmtSolvingMethod</code>","text":"<p>         Bases: <code>FmtSolvingBase</code></p> <p>Base class to define the structure of the solver. </p> <p>Any class inheriting from this base represents an algorithm used to  eliminate candidate options from the unsolved puzzle. </p> <p>The implementation of these algorithms happens by means of overloading the  abstract <code>launch</code> method. This method, taking the unsolved puzzle as  argument, executes the corresponding solving algorithm and depending on  its success decides what solving method to try next. That is, if the present algorithm succeeds at eliminating at least one candidate option, then the  <code>launch</code> method of the <code>_advance</code> attribute is invoked. On the other hand,  if the present algorithm fails at removing candidates, the unsolved puzzle  is passed to the <code>launch</code> implementation of the <code>_fall_back</code> attribute. Both, the <code>_advance</code> and the <code>_fall_back</code> object must therefore be an  instances of a children of <code>FmtSolvingMethod</code> themselves.</p> <p>If none of the implemented solving methods (i.e. non of the instances of the corresponding children of <code>FmtSolvingMethod</code>) manage to contribute to  the solution, the puzzle must be considered unsolvable. Therefore, the  <code>_fall_back</code> attribute defaults to <code>_SolvingFail()</code> which is a trivial  child of <code>FmtSolvingMethod</code> whose <code>launch</code> method raises an error. Hence, if  any solving-method object does not explicitly link a <code>_fall_back</code> instance, it is automatically considered to represent the worst case algorithm to be  tried as its failure implies the insolubility of the puzzle by this solver.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingMethod.launch","title":"<code>launch(S)</code>  <code>abstractmethod</code>","text":"<p>Interface method to invoke the internals of the Solving Algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>Sudoku</code> <p>The Sudoku puzzle to which the algorithm is applied</p> required"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.LoneSingles","title":"<code>LoneSingles</code>","text":"<p>         Bases: <code>FmtSolvingMethod</code></p> <p>The most basic solving method that is used to initiate the solving process. This method simply searches for the tiles whose value has already been  fixed and removes the respective number from its neighboring tiles.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.NTilesNOptions","title":"<code>NTilesNOptions</code>","text":"<p>         Bases: <code>FmtParamSolvingMethod</code></p> <p>A solving method that checks if a set of the same <code>n</code> options is found <code>n</code> times in the same row, column or square. If, e.g., the set of candidate options <code>{1,2}</code> is found twice in the same row, i.e., if two separate tiles have the exact same two candidates left, no other tile in the same row may take any of the latter two values. Notice that for <code>n=1</code>, this method is  equivalent to <code>LoneSingles</code>.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.RemoveAndUpdate","title":"<code>RemoveAndUpdate</code>","text":"<p>         Bases: <code>FmtSolvingBase</code></p> <p>Special solving-method class whose <code>launch</code> method implements the  functionality to remove candidates from specified tiles.  Correspondingly, this method should be invoked by the 'regular'  solving-method objects, i.e., by instances of classes that inherit from  <code>FmtSolvingMethod</code>.</p> <p>Moreover, the removal process also triggers the clean up methods <code>_single_occurrence_of_option</code> and <code>_remove_option_from_neighbors</code> which implement further candidate removal steps that are directly implied by the initial removal.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.RemoveAndUpdate.launch","title":"<code>launch(S, where, which)</code>","text":"<p>Interface to initiate the removal of the candidates <code>which</code> form the  tile at <code>where</code> of the Sudoku <code>S</code>.</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>Sudoku</code> <p>The puzzle</p> required <code>where</code> <code>int</code> <p>Index of the concerned tile</p> required <code>which</code> <code>set</code> <p>Candidates to be removed</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Could any candidates be removed?</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.RemoverMissingError","title":"<code>RemoverMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No remover has been assigned to the solving method.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.ScaledXWing","title":"<code>ScaledXWing</code>","text":"<p>         Bases: <code>FmtParamSolvingMethod</code></p> <p>Solving methods that searches for candidate options appearing in an  <code>n</code> x <code>n</code> square. </p> <p>Consider, e.g., two columns in which the same candidate occurs at exactly  two positions. Now, let the rows in which these occurrences are to be the same  for both columns. Then non of the remaining tiles within the latter tow rows  can take this candidate as value anymore as its position is already fixed to a place in either of the tow columns we considered initially.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.SolverError","title":"<code>SolverError</code>","text":"<p>         Bases: <code>RuntimeError</code></p> <p>The puzzle can't be solved with the given solver.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.StepperMissingError","title":"<code>StepperMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No stepper has been assigned to the solving method.</p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.YWing","title":"<code>YWing</code>","text":"<p>         Bases: <code>FmtSolvingMethod</code></p> <p>Implementation of the classical 'Y-Wing' strategy.</p> <p>This methods first searches for an 'anchor' tile, i.e., a tile with two candidates left, say <code>{1,2}</code>. From this tile on, the neighboring row, column and square are searched for further 'two-candidate' tiles. The aim, thereby, is to find two more tiles, one of them including <code>1</code> and the other <code>2</code> as  candidate. Most importantly these two tiles must also have one common candidate, say <code>3</code>, such that we end up with two 'node' tiles related to the anchor, having candidates <code>{1,3}</code> and <code>{2,3}</code>. No matter what configuration  eventually solves the puzzle, one of the node tiles must be assigned the value <code>3</code> as fixing the value of one node immediately fixes the value of the other node via the anchor tile. Consequently, <code>3</code> can  be excluded as candidate from any tile that is simultaneously related to  both nodes.</p>"},{"location":"api/sudoku/stepping/","title":"stepping","text":"<p>This module provides the base for any 'stepper' class plus a few example steppers used in the default solver. The steppers are devices used as backend  for the formatted output of the solving process. Stepper objects provide an  interface for the solving method classes to pass information about any  successfully eliminated candidate. Moreover, they are able to pause the solving process after any successful elimination to pass the latter information to any frontend, thus enabling the user to step through the solving process, possibly by means of a graphical output.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.AnyStep","title":"<code>AnyStep</code>","text":"<p>         Bases: <code>StepperBase</code></p> <p>Stepper class to transfer information about every elimination step to the frontend.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.AnyStep.show_step","title":"<code>show_step(sudoku, affected_tiles, affected_options)</code>","text":"<p>Invoke the render to print the solving step based on the previously specified consideration.</p> <p>Parameters:</p> Name Type Description Default <code>sudoku</code> <code>Sudoku</code> <p>The concerned puzzle</p> required <code>affected_tiles</code> <code>set</code> <p>The tiles affected by the present configuration             of the neighboring tiles</p> required <code>affected_options</code> <code>set</code> <p>The candidate to be removed from the latter tiles</p> required"},{"location":"api/sudoku/stepping/#sudoku.stepping.DeadStepper","title":"<code>DeadStepper</code>","text":"<p>         Bases: <code>StepperBase</code></p> <p>Trivial 'stepper' class serving as default value for any variable whose value must be of type <code>StepperBase</code>. That is, if no proper 'stepper' is assigned, this placeholder will raise an error whenever the user tries to  make use of the abstract methods that any stepper needs to implement.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.DeadTrigger","title":"<code>DeadTrigger</code>","text":"<p>         Bases: <code>NoTrigger</code></p> <p>Trivial trigger to raise an error when called. Such objects serve as  default argument for variables that take an object of type <code>NoTrigger</code> as value.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.InterestingStep","title":"<code>InterestingStep</code>","text":"<p>         Bases: <code>AnyStep</code></p> <p>Stepper with functionality analogous to <code>AnyStep</code> but only solving steps whose importance was set to 'interesting' by means of the respective  argument of the <code>set_consideration</code> method are rendered.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.NoTrigger","title":"<code>NoTrigger</code>","text":"<p>Classes that implement the functionality to await any sort uf user input after the puzzle has been rendered.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.NoTrigger.trigger_next_step","title":"<code>trigger_next_step()</code>","text":"<p>Trigger the next solving step.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.Skipper","title":"<code>Skipper</code>","text":"<p>         Bases: <code>StepperBase</code></p> <p>Trivial stepper class that only counts the solving steps without invoking any rendering or interrupting the solving process.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase","title":"<code>StepperBase</code>","text":"<p>Base class providing the template for any stepper by implementing a  solution-step counting mechanism and the interface to pass information about the current state of the puzzle through the stepper to the frontend.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.__init__","title":"<code>__init__(formatter=None, trigger=None)</code>","text":"<p>Create a stepper instance by passing a formatting function, i.e. a function to render the puzzle with additional information about the solving process</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.set_consideration","title":"<code>set_consideration(tiles, options, message, interesting=False)</code>  <code>abstractmethod</code>","text":"<p>Tell the stepper what <code>options</code> of what <code>tiles</code> we're currently  considering to draw conclusions about what candidates we can eliminate. The <code>message</code> will be printed at a successful elimination. The <code>interesting</code> parameter specifies the complexity of the consideration. </p> <p>Parameters:</p> Name Type Description Default <code>tiles</code> <code>set</code> <p>The tiles we consider to draw conclusion about possible  future removals of candidates of neighboring tiles</p> required <code>options</code> <code>set</code> <p>The candidates that allow for the latter conclusions</p> required <code>message</code> <code>str</code> <p>The message to pass to the render when successfully  removing candidates based on the latter conclusion. interesting: whether the removal step should be printed by a  stepper that only cares about elaborate algorithms</p> required"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.show","title":"<code>show(sudoku)</code>","text":"<p>Use the selected formatter to render the Sudoku without any information about the solving process.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.show_step","title":"<code>show_step(*args)</code>  <code>abstractmethod</code>","text":"<p>Invoke the frontend to print the current state of the Sudoku and  increase the solving step <code>counter</code> by one as this method is only called after a successful elimination of a candidate.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperMissingError","title":"<code>StepperMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No stepper has been assigned to the solving method.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.TriggerMissingError","title":"<code>TriggerMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No trigger has been assigned to the stepper.</p>"},{"location":"api/sudoku/structure/","title":"structure","text":"<p>This module provides the two classes <code>Tile</code> and <code>Sudoku</code> that serve as base structure for the solver to operate on. Observe that the abbreviations 'r', 'c' and 's' for row, column and square, stored in <code>CONTAINER_TYPES</code>, are used throughout this program. Square, thereby, refers to typical 3x3 tile  collections.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku","title":"<code>Sudoku</code>","text":"<p>Container structure to represent the Sudoku grid by storing 81 <code>Tile</code>  objects in a one dimensional list.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.containers","title":"<code>containers: Dict[str, List[List[int]]]</code>  <code>property</code>","text":"<p>Structure to store the indices of the tiles, i.e. their position in the <code>tiles</code> array, that live in each row, column and square. </p> <p>Consider the following example to retrieve the array positions of the  tiles that live in the first square:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Sudoku.containers['s'][0]\n[0, 1, 2, 9, 10, 11, 18, 19, 20]\n</code></pre> <p>Thereby, the subscript <code>['s'][0]</code> indicates the square at position 0.</p> <p>Returns:</p> Type Description <code>Dict[str, List[List[int]]]</code> <p>The containers (as described above)</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.done","title":"<code>done: bool</code>  <code>property</code>","text":"<p>Returns:      Whether the puzzle is solved</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.max_options","title":"<code>max_options: int</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The maximum number of candidates over all the tiles</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.occurrences","title":"<code>occurrences: Dict[str, List[List[Set[int]]]]</code>  <code>property</code>","text":"<p>For each row, column and square and for each number of 1 to 9, this  dictionary stores at which <code>tiles</code> positions the respective value still  appears as candidate.</p> <p>Consider the following example to retrieve the set of array positions at  which the candidate <code>9</code> is still found in the second row:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Sudoku.occurrences['r'][1][8]\n{9, 11, 15}\n</code></pre> <p>Thereby, <code>['r'][1]</code> indicates the second row and <code>[8]</code> specifies the  list position at which the occurrences of the value <code>9</code> are stored.</p> <p>Returns:</p> Type Description <code>Dict[str, List[List[Set[int]]]]</code> <p>The occurrences (as above duh xD)</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.tiles","title":"<code>tiles: List[Tile]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>List[Tile]</code> <p>List of length 81 to store every tile of the Sudoku grid.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_complexity_map","title":"<code>get_complexity_map()</code>","text":"<p>Returns:      The solving step a which the definite solution has been found      for each tile (organized row by row).</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_options","title":"<code>get_options()</code>","text":"<p>Returns:</p> Type Description <code>List[List[set]]</code> <p>The remaining candidates for each tile as set organized row by row</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_solved","title":"<code>get_solved()</code>","text":"<p>Returns:      The solved puzzle as a two-dimensional list.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_tiles","title":"<code>get_tiles()</code>","text":"<p>Returns:</p> Type Description <code>List[List[Tile]]</code> <p>The tiles organized row by row</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.is_valid","title":"<code>is_valid()</code>","text":"<p>Explicitly check whether the Sudoku rules have been violated in the  solving process. One should try to avoid explicit use of this method as the implementations of the solving algorithms should automatically  detect if such a violation has been taken place and correspondingly set  the <code>violated</code> attribute to <code>True</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Is the present configuration valid?</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile","title":"<code>Tile</code>","text":"<p>Structure to represent a tile of the Sudoku grid. Tile objects store the  position of a tile by means of specifying their row, column and square  index. Moreover, this class is needed to keep track of the possible  candidate values a tile can still take in the process of solving the puzzle.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile.options","title":"<code>options: set</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>set</code> <p>The remaining candidate values for this tile</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile.pos","title":"<code>pos: Dict[str, int]</code>  <code>property</code>","text":"<p>Get the row, column and square index of the tile formatted as <code>{'r': *row index*, 'c': *column index*, 's': *square index*}</code>.</p> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>The row, column and square index of the tile</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile.to_none_tile","title":"<code>to_none_tile(tile)</code>  <code>classmethod</code>","text":"<p>Create a tile that has no candidate values at the position of the  <code>tile</code> that is given as argument.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.index_to_pos","title":"<code>index_to_pos(t)</code>","text":"<p>Get the row, column and square index from the tile index <code>t</code> formatted as  <code>{'r': *row index*, 'c': *column index*, 's': *square index*}</code>.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>int</code> <p>The tile index</p> required <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict containing row, column and square index</p>"},{"location":"api/sudoku/structure/#sudoku.structure.row_column_to_index","title":"<code>row_column_to_index(r, c)</code>","text":"<p>Get the tile index, i.e. the position of the tile in an array of dimension <code>81</code>, by specifying the row <code>r</code> and the column <code>c</code>.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Row index</p> required <code>c</code> <code>int</code> <p>Column index</p> required <p>Returns:</p> Type Description <code>int</code> <p>Tile index</p>"}]}