{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sudokumentation","text":""},{"location":"#welcome-to-the-documentation-of-the-sudoku2-package","title":"Welcome to the documentation of the sudoku2 package!","text":"<p>These docs shall give you an overview of the possible applications of the package; On the one hand, its built in solver can be comfortably used to guide you step-by-step to the solution of a Sudoku puzzle. On the other hand, the package provides an API which lets you easily extend the capabilities of the basic solver by adding custom solving algorithms or by implementing any arbitrary Python frontend to render the individual solving steps. </p> <p>Warning</p> <p>Even the core functionality of the Package is still in development. Both the API and the features that are abstracted by it may still change heavily. Proceed with caution if you intend to integrate this package in your own project. Moreover, if you are reading this from a development branch, the docs may not exactly correspond to the present state of the code.</p>"},{"location":"#contents","title":"Contents","text":"<p>Info</p> <p>For any use of the package that goes beyond the Standard Solver, it's strongly recommended to start the journey through these docs with the description of the Solving Process. </p> <p>If you intend to use the package as a stand-alone tool to solve Sudoku puzzles, please refer to:</p> <ul> <li>Standard Solver - simple functional access to the pre-built solver</li> <li>Custom Solver - create a custom solver by explicitly deciding what solving algorithms to use and what solving steps to render</li> </ul> <p>If you're interested in modifying the basic capabilities or to use the solver backend in your own project, refer to the API Guide.</p>"},{"location":"api_guide/","title":"API Guide","text":""},{"location":"custom_solver/","title":"Create a Custom Solver","text":"<p>This document aims at explaining the API of the library by walking you through the process of assembling a custom solver object. We will thereby create an implementation for a very basic solving algorithm and </p>"},{"location":"solving_process/","title":"Solving Process","text":"<p>When working with the Custom Solver or when making use of the API, your interaction with the package goes beyond the simplified functional access and you will be confronted with the objects that, e.g., represent the solving algorithms of the rendering frontend. In order to understand how these objects interact with each other, a basic understanding of the solving procedure, illustrated by the flowchart below, is indispensible.</p> <p>We come back to some specific nodes of the diagram when discussing the API or the Custom Solver generator.</p>"},{"location":"solving_process/#a-word-of-caution","title":"A Word of Caution","text":"<p>Since there are some severe differences between the implemented solving algorithms, the API does not force you (so far) to entirely stick to the prescription suggested by the diagram. For example, you are free to decide whether to implement a loop over tiles or to replace it by a better suiting approach.</p> <p>Note</p> <p>Future versions may address this inconvenience by providing a further abstraction that ultimately forces you to stick to the suggested prescription by means of an intermediate abstract class. Since, however, the procedures that are not abstracted are very simple (they come in form of simple conditions or loops), further abstraction may also be omitted completely, to make the code more readable.</p>"},{"location":"solving_process/#flowchart","title":"Flowchart","text":"<pre><code>flowchart\n    init([Launch Solver]) --&gt; InitialAlgorithm[Use initial Algorithm]\n    InitialAlgorithm --&gt; LaunchSolver[Launch Algorithm] \n    LaunchSolver --&gt; Solved{Puzzle \\nsolved?}\n\n    Solved --yes--&gt; Return([Return Solved Puzzle])\n\n    Solved --no---&gt; SolverLoop[Loop over Tiles]\n    SolverLoop --&gt; Increase[Next Tile]\n    Increase --&gt; TerminateLoop{Last \\nitem?}\n\n    TerminateLoop --Yes--&gt; CheckSuccess{Algorithm \\ncould remove \\nat least one\\n candidate?}\n\n    CheckSuccess --No---&gt; FallbackLeft{Fallback \\nAlgorithm \\nspecified?}\n    FallbackLeft --yes--&gt; Fallback[Continue with Fallback Algorithm]\n\n    CheckSuccess --yes--&gt; Advance[Continue with less elaborate Algorithm]\n    Fallback &amp; Advance --&gt; LaunchSolver\n\n    FallbackLeft --no--&gt; Fail([Can't solve puzzle])\n\n    TerminateLoop --No--&gt; FindPattern[[Search for Pattern on the Sudoku grid \\nthat lets us deduce \\nwhat Candidates we can remove \\nfrom neighboring Tiles]]\n    FindPattern --&gt; PatternFound{Pattern \\nmatched?}\n\n    PatternFound --no--&gt; Increase\n\n    PatternFound --yes--&gt; TryRemove[Check if there are any Candidates \\nconcerned by the Pattern]\n    TryRemove --&gt; ToRemove{Concerned\\ncandidates\\nfound?}\n\n    ToRemove --no--&gt; Increase\n\n    ToRemove --yes--&gt; Remove[Remove Candidates]\n    Remove --&gt; Render{{Render Solving Step}}\n    Render --&gt; Trigger[Trigger Next Step]\n    Trigger --&gt; CleanUp[[Update Routine involving very basic Solving Algorithms]]\n    CleanUp --&gt; Increase\n</code></pre>"},{"location":"standard_solvers/","title":"Using the Standard Solver","text":""},{"location":"api/modules/","title":"Modules","text":"<ul> <li>sudoku<ul> <li>consolesolver</li> <li>formatting</li> <li>solvertools</li> <li>solvingmethods</li> <li>stepping</li> <li>structure</li> </ul> </li> </ul>"},{"location":"api/sudoku/consolesolver/","title":"consolesolver","text":"<p>Example module to illustrate a coupling of the solver to the console as  frontend. Therefore, a corresponding <code>Trigger</code> and <code>Formatter</code> class must be implemented.</p>"},{"location":"api/sudoku/consolesolver/#sudoku.consolesolver.ConsoleFormatter","title":"<code>ConsoleFormatter</code>","text":"<p>         Bases: <code>BlankFormatter</code></p> <p>Basic formatter to print the solutions steps, i.e. the partially solved puzzle, to the console. Use the <code>flush</code> attribute to decide whether the  solution steps are stringed together in the console or if the previous step is consecutively removed.</p> Source code in <code>sudoku\\consolesolver.py</code> <pre><code>class ConsoleFormatter(BlankFormatter):\n\"\"\"\n    Basic formatter to print the solutions steps, i.e. the partially solved\n    puzzle, to the console. Use the `flush` attribute to decide whether the \n    solution steps are stringed together in the console or if the previous step\n    is consecutively removed. \n    \"\"\"\n    H_LINE_CHAR = u\"\\u2500\"\n    V_LINE_CHAR = u\"\\u2502\"\n    CROSS_CHAR = u\"\\u253c\"\n    LU_ANGLE = u\"\\u256d\"\n    LL_ANGLE = u\"\\u2570\"\n    RU_ANGLE = u\"\\u256e\"\n    RL_ANGLE = u\"\\u256f\"\n    L_T = u\"\\u251c\"\n    R_T = u\"\\u2524\"\n    U_T = u\"\\u252c\"\n    D_T = u\"\\u2534\"\n\n    def __init__(self, render_message=True, flush=False) -&gt; None:\n        self.flush = flush\n        self.r_msg = render_message\n\n    def _format_tile(self, options: set, considered: set, affected: set) -&gt; str:\n        colorized = []\n        for opt in options:\n            if opt in considered:\n                colorized.append(f\"\\033[92m{opt}\\033[39m\")\n            elif opt in affected:\n                colorized.append(f\"\\033[91m{opt}\\033[39m\")\n            else:\n                colorized.append(str(opt))\n\n        joined = \",\".join(colorized)\n        return f\"[{joined}]\"\n\n    def _get_row_delimiter(self, left, center, right, width, main):\n        return f\"{left}{main}{(main+center+main).join([(width)*main]*3)}{main}{right}\\n\"\n\n    def _prepare_string(self, sudoku: Sudoku, considered_tiles: Set[int], considered_options: Set[int], affected_tiles: Set[int], affected_options: Set[int]):\n        tiles = sudoku.tiles\n        tile_width = sudoku.max_options*2+1\n        square_width = tile_width*3\n        row_strs = \"\"\n\n        row_strs += self._get_row_delimiter(self.LU_ANGLE, self.U_T, self.RU_ANGLE, square_width, self.H_LINE_CHAR)\n\n        for row in range(9):\n            col_strs = f\"{self.V_LINE_CHAR} \"\n            for col in range(9):\n                tile_index = 9*row+col\n                tile = tiles[tile_index]\n\n                in_tile_considered = set() if not tile_index in considered_tiles else tile.options&amp;considered_options\n                in_tile_affected = set() if not tile_index in affected_tiles else tile.options&amp;affected_options\n\n                col_strs += f\"{self._format_tile(tile.options, in_tile_considered, in_tile_affected)}{(tile_width-tile.n_options*2-1)*' '}\"\n\n                if (c:=col+1)%3==0 and c &lt; 9:\n                    col_strs += f\" {self.V_LINE_CHAR} \"\n\n            row_strs += f\"{col_strs} {self.V_LINE_CHAR}\\n\"\n\n            if (r:=row+1)%3==0 and r &lt; 9:\n                row_strs += self._get_row_delimiter(self.L_T, self.CROSS_CHAR, self.R_T, square_width, self.H_LINE_CHAR)\n\n        row_strs += self._get_row_delimiter(self.LL_ANGLE, self.D_T, self.RL_ANGLE, square_width, self.H_LINE_CHAR)\n        return row_strs\n\n    def render(self, sudoku: Sudoku, considered_tiles=None, considered_options=None, affected_tiles=None, affected_options=None, solving_step: int = 0, solving_message: str = None):\n        defaults = super().render(sudoku, considered_tiles, considered_options, affected_tiles, affected_options, solving_step, solving_message)\n        if self.flush:\n            print(\"\\033[H\\033[J\", end=\"\")\n\n        print(f\"solving step {solving_step}: {solving_message}\")\n        print(f\"status: {'violated' if sudoku.violated else 'ok'}\")\n        print(self._prepare_string(sudoku, **defaults))\n</code></pre>"},{"location":"api/sudoku/consolesolver/#sudoku.consolesolver.ConsoleTrigger","title":"<code>ConsoleTrigger</code>","text":"<p>         Bases: <code>NoTrigger</code></p> <p>Trigger that requires the user to press 'enter' to show the next solving step.</p> Source code in <code>sudoku\\consolesolver.py</code> <pre><code>class ConsoleTrigger(NoTrigger):\n\"\"\"\n    Trigger that requires the user to press 'enter' to show the next solving\n    step.\n    \"\"\"\n    def trigger_next_step(self) -&gt; None:\n        answering = True\n        while answering:\n            if not input(\"next step: (press ENTER)\"):\n                answering = False\n            else:\n                print(\"JUST HIT ENTER!\")\n</code></pre>"},{"location":"api/sudoku/consolesolver/#sudoku.consolesolver.solve","title":"<code>solve(sudoku, stepping, flush=False)</code>","text":"<p>Solve a Sudoku given as <code>Sudoku</code> object (possibly obtained by the <code>load</code> function). Use the <code>stepping</code> parameter to choose between the steppers  'any', to render every solving step, 'skip' to completely suppress  rendering, or 'interesting' to only print more elaborate solving methods.  Use the <code>flush</code> parameter to erase the rendered output of the previous  solving step before continuing.</p> <p>Parameters:</p> Name Type Description Default <code>sudoku</code> <code>Sudoku</code> <p>The puzzle to solve</p> required <code>stepping</code> <code>str</code> <p>Specify what solving steps to render</p> required <code>flush</code> <code>bool</code> <p>Set to <code>True</code> to erase the previous solving step</p> <code>False</code> <p>Returns:</p> Type Description <code>Sudoku</code> <p>The solved puzzle</p> Source code in <code>sudoku\\consolesolver.py</code> <pre><code>def solve(sudoku: Sudoku, stepping: str, flush: bool = False) -&gt; Sudoku:\n\"\"\"\n    Solve a Sudoku given as `Sudoku` object (possibly obtained by the `load`\n    function). Use the `stepping` parameter to choose between the steppers \n    'any', to render every solving step, 'skip' to completely suppress \n    rendering, or 'interesting' to only print more elaborate solving methods. \n    Use the `flush` parameter to erase the rendered output of the previous \n    solving step before continuing.\n\n    Args:\n        sudoku: The puzzle to solve\n        stepping: Specify what solving steps to render\n        flush: Set to `True` to erase the previous solving step\n\n    Returns:\n        The solved puzzle\n    \"\"\"\n\n    stepper = _STEPPERS[stepping](ConsoleFormatter(flush=flush), ConsoleTrigger())\n    solver = _create_solver(stepper)\n    s = solver.launch(sudoku)\n    stepper.show(s)\n    return s\n</code></pre>"},{"location":"api/sudoku/formatting/","title":"formatting","text":"<p>This module provides the base class for <code>Formatter</code> objects.</p>"},{"location":"api/sudoku/formatting/#sudoku.formatting.BlankFormatter","title":"<code>BlankFormatter</code>","text":"<p>Formatters implement the <code>render</code> method called by any stepper to print the progress of the solver to the screen by any means.</p> Source code in <code>sudoku\\formatting.py</code> <pre><code>class BlankFormatter:\n\"\"\"\n    Formatters implement the `render` method called by any stepper to print the\n    progress of the solver to the screen by any means.\n    \"\"\"\n    def _get_defaults(self, considered_tiles, considered_options, affected_tiles, affected_options):\n        return {\n            \"considered_tiles\": considered_tiles if considered_tiles else set(),\n            \"considered_options\": considered_options if considered_options else set(),\n            \"affected_tiles\": affected_tiles if affected_tiles else set(),\n            \"affected_options\": affected_options if affected_options else set()\n        }\n\n    @abstractmethod\n    def render(self, \n        sudoku: Sudoku, \n        considered_tiles=None, \n        considered_options=None, \n        affected_tiles=None,\n        affected_options=None, \n        solving_step: int = 0, \n        solving_message: str = None):\n\"\"\"\n        Print the Sudoku to the screen by the mean of your desire\n        \"\"\"\n        return self._get_defaults(\n            considered_tiles, considered_options,\n            affected_tiles, affected_options)\n</code></pre>"},{"location":"api/sudoku/formatting/#sudoku.formatting.BlankFormatter.render","title":"<code>render(sudoku, considered_tiles=None, considered_options=None, affected_tiles=None, affected_options=None, solving_step=0, solving_message=None)</code>  <code>abstractmethod</code>","text":"<p>Print the Sudoku to the screen by the mean of your desire</p> Source code in <code>sudoku\\formatting.py</code> <pre><code>@abstractmethod\ndef render(self, \n    sudoku: Sudoku, \n    considered_tiles=None, \n    considered_options=None, \n    affected_tiles=None,\n    affected_options=None, \n    solving_step: int = 0, \n    solving_message: str = None):\n\"\"\"\n    Print the Sudoku to the screen by the mean of your desire\n    \"\"\"\n    return self._get_defaults(\n        considered_tiles, considered_options,\n        affected_tiles, affected_options)\n</code></pre>"},{"location":"api/sudoku/formatting/#sudoku.formatting.DeadFormatter","title":"<code>DeadFormatter</code>","text":"<p>         Bases: <code>BlankFormatter</code></p> <p>Trivial formatter to raise an error when its <code>render</code> method is called. Such objects serve as default value for variables that take an object of  type <code>BlankFormatter</code> as value.</p> Source code in <code>sudoku\\formatting.py</code> <pre><code>class DeadFormatter(BlankFormatter):\n\"\"\"\n    Trivial formatter to raise an error when its `render` method is called.\n    Such objects serve as default value for variables that take an object of \n    type `BlankFormatter` as value.\n    \"\"\"\n    def render(self, *args):\n        raise FormatterMissingError()\n</code></pre>"},{"location":"api/sudoku/formatting/#sudoku.formatting.FormatterMissingError","title":"<code>FormatterMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No formatter has been assigned to the stepper.</p> Source code in <code>sudoku\\formatting.py</code> <pre><code>class FormatterMissingError(NotImplementedError):\n\"\"\"\n    No formatter has been assigned to the stepper.\n    \"\"\"\n    def __init__(self) -&gt; None:\n        super().__init__(\"no formatter has been assigned to the stepper\")\n</code></pre>"},{"location":"api/sudoku/solvertools/","title":"solvertools","text":"<p>Module providing the core tools to build and interact with a Sudoku solver.</p>"},{"location":"api/sudoku/solvertools/#sudoku.solvertools.generate_solver","title":"<code>generate_solver(method_order, stepper)</code>","text":"<p>Build a Sudoku solver by deciding in what order the solving methods (i.e. the instances of <code>FmtSolvingMethod</code> classes) are chained together. The  order of the <code>method_order</code> array implies that after the failure of the  n-th method, the n+1-th method will be used. On the other hand, at success of the n-th method, the solver will proceed by calling the 1st element of <code>method_order</code>. Moreover, any <code>StepperBase</code> object must be provided to guide the user through the solving process.</p> Source code in <code>sudoku\\solvertools.py</code> <pre><code>def generate_solver(method_order: Tuple[FmtSolvingMethod], stepper: StepperBase):\n\"\"\"\n    Build a Sudoku solver by deciding in what order the solving methods (i.e.\n    the instances of `FmtSolvingMethod` classes) are chained together. The \n    order of the `method_order` array implies that after the failure of the \n    n-th method, the n+1-th method will be used. On the other hand, at success\n    of the n-th method, the solver will proceed by calling the 1st element of\n    `method_order`. Moreover, any `StepperBase` object must be provided to guide\n    the user through the solving process.\n    \"\"\"\n\n    remover = RemoveAndUpdate(stepper)\n    init_methods: List[FmtSolvingMethod] = []\n\n    init_run = NTilesNOptions(1, stepper, remover)\n\n    for method in method_order:\n        method.set_stepper(stepper)\n        method.set_remover(remover)\n        init_methods.append(method)\n\n    init_run.set_fall_back(init_methods[0])\n    init_methods[-1].set_advance(init_methods[0])\n\n    for i in range(0, len(method_order)-1):\n        method = init_methods[i]\n        method.set_advance(init_methods[0])\n        method.set_fall_back(init_methods[i+1])\n\n    return init_run\n</code></pre>"},{"location":"api/sudoku/solvertools/#sudoku.solvertools.load","title":"<code>load(path)</code>","text":"<p>Load a Sudoku puzzle stored as <code>csv</code> file at <code>path</code> and build a <code>Sudoku</code> structure form the tow-dimensional grid.</p> Source code in <code>sudoku\\solvertools.py</code> <pre><code>def load(path: Path) -&gt; Sudoku:\n\"\"\"\n    Load a Sudoku puzzle stored as `csv` file at `path` and build a `Sudoku`\n    structure form the tow-dimensional grid.\n    \"\"\"\n    with open(path) as csv_file:\n        rows = reader(csv_file, skipinitialspace=True)\n        content = [(int(elt) if elt else 0) for row in rows for elt in row]\n\n    sudoku = Sudoku(content)\n    return sudoku\n</code></pre>"},{"location":"api/sudoku/solvertools/#sudoku.solvertools.save","title":"<code>save(sudoku, path)</code>","text":"<p>Write the solved <code>sudoku</code> puzzle to a <code>csv</code> file at <code>path</code></p> Source code in <code>sudoku\\solvertools.py</code> <pre><code>def save(sudoku: Sudoku, path: Path):\n\"\"\"\n    Write the solved `sudoku` puzzle to a `csv` file at `path`\n    \"\"\"\n    with open(path, \"w\", newline=\"\") as csv_file:\n        writer(csv_file).writerows(sudoku.get_solved())\n</code></pre>"},{"location":"api/sudoku/solvingmethods/","title":"solvingmethods","text":"<p>Core module of the solver, providing the structure of the different solving algorithms by means of the base classes <code>FmtSolvingBase</code> and  <code>FmtSolvingMethod</code>. These classes work as templates for the integration of the specific solving algorithms through their child classes but also provide  the abstract interface to access these algorithms. </p> <p>Use this module to integrate your own solving algorithms to this solver or to access the four default solving methods: <code>NTilesNOptions</code>, <code>ScaledXWing</code>,  <code>YWing</code> and <code>Bifurcation</code>.</p> <p>Moreover, this file also provides the device required to remove candidates from  Sudoku tiles. Observe that the implemented algorithms are not able to solve the  puzzle on their own but depend on a prescription of what algorithm to use in the  specific state of the puzzle. This logic is implemented by means of any  solving-method class having attributes that link to other solving-method classes which are to be used depending on the success or failure of the present solving  algorithm. The linking of the solving methods is done via the <code>generate_solver</code>  function found in <code>solver.py</code></p>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.Bifurcation","title":"<code>Bifurcation</code>","text":"<p>         Bases: <code>FmtSolvingMethod</code></p> <p>The uninspired emergency solving method.</p> <p>After failure of the previous algorithms, we may still fall back to a trial and error approach by considering tiles with two candidates left and by mindlessly picking one of them as the tiles value. From there on, we can  continue solving the puzzle with the 'more analytic' methods until we  either solve to puzzle or run into a violation of the Sudoku rules. Since we only apply this approach to 'two-candidate' tiles, a failure of the try still immediately fixes the definitive value of the considered tile.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class Bifurcation(FmtSolvingMethod):\n\"\"\"\n    The uninspired emergency solving method.\n\n    After failure of the previous algorithms, we may still fall back to a trial\n    and error approach by considering tiles with two candidates left and by\n    mindlessly picking one of them as the tiles value. From there on, we can \n    continue solving the puzzle with the 'more analytic' methods until we \n    either solve to puzzle or run into a violation of the Sudoku rules. Since\n    we only apply this approach to 'two-candidate' tiles, a failure of the try\n    still immediately fixes the definitive value of the considered tile.\n    \"\"\"\n\n    def launch(self, S: Sudoku):\n        for tile_index in range(81):\n            tile = S.tiles[tile_index]\n            if tile.n_options == 2:\n\n                opts = deepcopy(tile.options)\n\n                backup = deepcopy(S)\n                try_option = opts.pop()\n                alt_option = opts.pop()\n\n                self._stepper.set_consideration(\n                    {tile_index},\n                    {alt_option},\n                    f\"bifurcation at {tile_index}; try {alt_option}\",\n                    True)\n\n                self._remove.launch(backup, tile_index, {try_option})\n                if not (out:=self._advance.launch(backup)):\n\n\n                    self._stepper.set_consideration(\n                        {tile_index},\n                        {try_option},\n                        f\"bifurcation at {tile_index} with {alt_option} failed, go with {try_option} instead\",\n                        True)\n\n                    backup = deepcopy(S)\n                    self._remove.launch(backup, tile_index, {alt_option})\n                    out = self._advance.launch(backup)\n\n                return out\n\n        return self._fall_back.launch(S)\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtParamSolvingMethod","title":"<code>FmtParamSolvingMethod</code>","text":"<p>         Bases: <code>FmtSolvingMethod</code></p> <p>Base class for solving methods that depend on a parameter. The minimum value the parameter takes is specified by the <code>_N_MIN</code> class variable which varies between the different solving method classes that inherit from the present class. </p> <p>The solving method's parameter is set at initialization of any such object;  if the given parameter is smaller than <code>_N_MIN</code>, a corresponding error terminates the program.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class FmtParamSolvingMethod(FmtSolvingMethod):\n\"\"\"\n    Base class for solving methods that depend on a parameter. The minimum value\n    the parameter takes is specified by the `_N_MIN` class variable which varies\n    between the different solving method classes that inherit from the present\n    class. \n\n    The solving method's parameter is set at initialization of any such object; \n    if the given parameter is smaller than `_N_MIN`, a corresponding error\n    terminates the program.\n    \"\"\"\n\n    _N_MIN = 1\n\n    def __init__(self, param: int, stepper: StepperBase = None, remover: RemoveAndUpdate = None) -&gt; None:\n        super().__init__(stepper, remover)\n        if param &gt;= self._N_MIN:\n            self._n = param\n        else:\n            raise ValueError(f\"parameter of {self.__class__.__name__} solving method must be larger or equal to {self._N_MIN} but {param} is given\")\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingBase","title":"<code>FmtSolvingBase</code>","text":"<p>Class to define the basic structure of any object the Sudoku solver  consists of. Such child classes must always implement a <code>launch</code> method  which, in the case of the <code>RemoveAndUpdate</code> class, invokes the removal  process whereas in the case of any regular solving method (i.e. of any  class inheriting from <code>FmtSolvingMethod</code>), the respective solving algorithm will be invoked.</p> <p>Any such class has a <code>_stepper</code> attribute which is the tool needed to guide the user through the solving process and to collect information thereof.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class FmtSolvingBase:\n\"\"\"\n    Class to define the basic structure of any object the Sudoku solver \n    consists of. Such child classes must always implement a `launch` method \n    which, in the case of the `RemoveAndUpdate` class, invokes the removal \n    process whereas in the case of any regular solving method (i.e. of any \n    class inheriting from `FmtSolvingMethod`), the respective solving algorithm\n    will be invoked.\n\n    Any such class has a `_stepper` attribute which is the tool needed to guide\n    the user through the solving process and to collect information thereof.\n    \"\"\"\n\n    def __init__(self, stepper: StepperBase = None) -&gt; None:\n        self._stepper = stepper if stepper else DeadStepper(self.__class__.__name__)\n\n    def set_stepper(self, stepper: StepperBase):\n        self._stepper = stepper\n\n    @abstractmethod\n    def launch(self, S: Sudoku, *args):\n\"\"\"\n        Interface method to invoke the internals of the corresponding solving\n        algorithm.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingBase.launch","title":"<code>launch(S, *args)</code>  <code>abstractmethod</code>","text":"<p>Interface method to invoke the internals of the corresponding solving algorithm.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>@abstractmethod\ndef launch(self, S: Sudoku, *args):\n\"\"\"\n    Interface method to invoke the internals of the corresponding solving\n    algorithm.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.FmtSolvingMethod","title":"<code>FmtSolvingMethod</code>","text":"<p>         Bases: <code>FmtSolvingBase</code></p> <p>Base class to define the structure of the solver. </p> <p>Any class inheriting from this base represents an algorithm used to  eliminate candidate options from the unsolved puzzle. </p> <p>The implementation of these algorithms happens by means of overloading the  abstract <code>launch</code> method. This method, taking the unsolved puzzle as  argument, executes the corresponding solving algorithm and depending on  its success decides what solving method to try next. That is, if the present algorithm succeeds at eliminating at least one candidate option, then the  <code>launch</code> method of the <code>_advance</code> attribute is invoked. On the other hand,  if the present algorithm fails at removing candidates, the unsolved puzzle  is passed to the <code>launch</code> implementation of the <code>_fall_back</code> attribute. Both, the <code>_advance</code> and the <code>_fall_back</code> object must therefore be an  instances of a children of <code>FmtSolvingMethod</code> themselves.</p> <p>If none of the implemented solving methods (i.e. non of the instances of the corresponding children of <code>FmtSolvingMethod</code>) manage to contribute to  the solution, the puzzle must be considered unsolvable. Therefore, the  <code>_fall_back</code> attribute defaults to <code>_SolvingFail()</code> which is a trivial  child of <code>FmtSolvingMethod</code> whose <code>launch</code> method raises an error. Hence, if  any solving-method object does not explicitly link a <code>_fall_back</code> instance, it is automatically considered to represent the worst case algorithm to be  tried as its failure implies the insolubility of the puzzle by this solver.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class FmtSolvingMethod(FmtSolvingBase):\n\"\"\"\n    Base class to define the structure of the solver. \n\n    Any class inheriting from this base represents an algorithm used to \n    eliminate candidate options from the unsolved puzzle. \n\n    The implementation of these algorithms happens by means of overloading the \n    abstract `launch` method. This method, taking the unsolved puzzle as \n    argument, executes the corresponding solving algorithm and depending on \n    its success decides what solving method to try next. That is, if the present\n    algorithm succeeds at eliminating at least one candidate option, then the \n    `launch` method of the `_advance` attribute is invoked. On the other hand, \n    if the present algorithm fails at removing candidates, the unsolved puzzle \n    is passed to the `launch` implementation of the `_fall_back` attribute.\n    Both, the `_advance` and the `_fall_back` object must therefore be an \n    instances of a children of `FmtSolvingMethod` themselves.\n\n    If none of the implemented solving methods (i.e. non of the instances of\n    the corresponding children of `FmtSolvingMethod`) manage to contribute to \n    the solution, the puzzle must be considered unsolvable. Therefore, the \n    `_fall_back` attribute defaults to `_SolvingFail()` which is a trivial \n    child of `FmtSolvingMethod` whose `launch` method raises an error. Hence, if \n    any solving-method object does not explicitly link a `_fall_back` instance,\n    it is automatically considered to represent the worst case algorithm to be \n    tried as its failure implies the insolubility of the puzzle by this solver.\n    \"\"\"\n\n    def __init__(self, stepper: StepperBase = None, remover: RemoveAndUpdate = None) -&gt; None:\n        super().__init__(stepper)\n        self._remove = remover if remover else _DeadRemover(self.__class__.__name__)\n        self._advance = self\n        self._fall_back = _SolvingFail()\n\n    def set_remover(self, remover: RemoveAndUpdate):\n        self._remove = remover\n\n    def set_fall_back(self, fall_back: FmtSolvingMethod):\n        self._fall_back = fall_back\n\n    def set_advance(self, advance: FmtSolvingMethod):\n        self._advance = advance\n\n    @abstractmethod\n    def launch(self, S: Sudoku):\n        pass\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.NTilesNOptions","title":"<code>NTilesNOptions</code>","text":"<p>         Bases: <code>FmtParamSolvingMethod</code></p> <p>A solving method that checks if a set of the same <code>n</code> options is found <code>n</code> times in the same row, column or square. If, e.g., the set of candidate options <code>{1,2}</code> is found twice in the same row, i.e., if two separate tiles have the exact same two candidates left, no other tile in the same row may take any of the latter two values.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class NTilesNOptions(FmtParamSolvingMethod):\n\"\"\"\n    A solving method that checks if a set of the same `n` options is found `n`\n    times in the same row, column or square. If, e.g., the set of candidate\n    options `{1,2}` is found twice in the same row, i.e., if two separate tiles\n    have the exact same two candidates left, no other tile in the same row may\n    take any of the latter two values.\n    \"\"\"\n\n    _N_MIN = 1\n\n    def _get_solving_message(self, n: int, kind: str, c_index: int, matches: set, shared_options: set):\n        c_name = CONTAINER_NAMES[kind]\n        if n==1:\n            return f\"tile {matches} in {c_name} {c_index} has fixed value {shared_options}; this option is thus removed from the remaining tiles in {c_name} {c_index}\"\n        else:\n            return f\"tiles {matches} in {c_name} {c_index} share options {shared_options}; removing these options from the remaining tiles in {c_name} {c_index}\"\n\n    def _get_equivalent_tiles(self, S: Sudoku, where: Set[int], tile_index: int) -&gt; Set[int]:\n\"\"\"\n        return indices of all tiles within `where` that have the same options \n        as the tile at `which` (`which` is also included).\n        \"\"\"\n\n        if (tile:=S.tiles[tile_index]).n_options == 1:\n            return {tile_index}\n\n        else:\n            matches = set()\n            for tile_index in where:\n                if S.tiles[tile_index].options == tile.options:\n                    matches.add(tile_index)\n            return matches if len(matches)==tile.n_options else set()\n\n    def _n_times_n_options_removal_container(self, S: Sudoku, kind: str, container_index: int, n: int) -&gt; bool:\n        success = False\n        container = S.containers[kind][container_index]\n\n        for tile_index in container:\n            if len(matches:=self._get_equivalent_tiles(S, container, tile_index)) == n:\n\n                shared_options = S.tiles[tile_index].options\n\n                for unmatched in set(container)-matches:\n                    self._stepper.set_consideration(\n                        matches,\n                        shared_options,\n                        self._get_solving_message(n, kind, container_index, matches, shared_options),\n                        n&gt;1)\n\n                    if self._remove.launch(S, unmatched, shared_options):\n                        success = True\n\n                    if S.violated:\n                        return False\n\n        return success\n\n    def launch(self, S: Sudoku):\n        success = False\n        if S.done:\n            return S\n        else:\n            for kind in CONTAINER_TYPES:\n                for kind_index in range(9):\n                    if S.violated:\n                        return False\n\n                    if self._n_times_n_options_removal_container(S, kind, kind_index, self._n):\n                        success = True\n                        # return self._advance.launch(S)\n\n            if success:\n                return self._advance.launch(S)\n            else:\n                return self._fall_back.launch(S)\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.RemoveAndUpdate","title":"<code>RemoveAndUpdate</code>","text":"<p>         Bases: <code>FmtSolvingBase</code></p> <p>Special solving-method class whose <code>launch</code> method implements the  functionality to remove candidates from specified tiles.  Correspondingly, this method should be invoked by the 'regular'  solving-method objects, i.e., by instances of classes that inherit from  <code>FmtSolvingMethod</code>.</p> <p>Moreover, the removal process also triggers the clean up methods <code>_single_occurrence_of_option</code> and <code>_remove_option_from_neighbors</code> which implement further candidate removal steps that are directly implied by the initial removal.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class RemoveAndUpdate(FmtSolvingBase):\n\"\"\"\n    Special solving-method class whose `launch` method implements the \n    functionality to remove candidates from specified tiles. \n    Correspondingly, this method should be invoked by the 'regular' \n    solving-method objects, i.e., by instances of classes that inherit from \n    `FmtSolvingMethod`.\n\n    Moreover, the removal process also triggers the clean up methods\n    `_single_occurrence_of_option` and `_remove_option_from_neighbors` which\n    implement further candidate removal steps that are directly implied by the\n    initial removal.\n    \"\"\"\n\n    def _single_occurrence_of_option(self, S: Sudoku, tile_index: int, remove_options: set):\n\"\"\"\n        There is the possibility that one of the `remove_options` we removed \n        from the tile at `tile_index` has been shared with a single other tile\n        that lives, e.g., in the same row. Hence, after the removal, this latter\n        tile is the only one in the row that still exhibits the concerned \n        candidate such that its value can immediately be fixed\n        \"\"\"\n\n        tile = S.tiles[tile_index]\n        for kind in CONTAINER_TYPES:\n            occurrence = S.occurrences[kind][tile.pos[kind]]\n            for o in remove_options:\n                if len(occurrence[o-1]) == 1:\n                    where_only_one_left: int = list(occurrence[o-1])[0]\n                    remove_opts = deepcopy(S.tiles[where_only_one_left].options)-{o}\n\n                    self._stepper.set_consideration(\n                        {where_only_one_left},\n                        {o},\n                        f\"tile {where_only_one_left} is the only tile in {CONTAINER_NAMES[kind]} {tile.pos[kind]+1} with {o} as option\",\n                        True)\n\n                    self.launch(S, where_only_one_left, remove_opts)\n\n                if S.violated:\n                    return False\n\n        return True\n\n    def _remove_option_from_neighbors(self, S: Sudoku, tile_index: int):\n\"\"\"\n        After having removed the specified candidates from the tile at \n        `tile_index`, the concerned tile may have only one candidate left, i.e.\n        its value is fixed by the previous removal. Therefore, its value must\n        not be considered a candidate of any neighboring tile anymore.\n        \"\"\"\n\n        tile = S.tiles[tile_index]\n        for kind in CONTAINER_TYPES:\n            container = S.containers[kind][tile.pos[kind]]\n            for t_idx in set(container)-{tile_index}:\n\n                self._stepper.set_consideration(\n                    {tile_index},\n                    tile.options,\n                    f\"value of tile {tile_index} has been fixed to {tile.options}, thus removing this option from tile {t_idx}\",\n                    False)\n\n                self.launch(S, t_idx, tile.options)\n\n                if S.violated:\n                    return False\n\n        return True\n\n    def _update_chain_removal(self, S: Sudoku, tile_index: int, remove_options: set):\n\"\"\"\n        Intermediate method, to invoke the clean up methods after the removal\n        of the `remove_options` from the tile at `tile_index`.\n        \"\"\"\n\n        tile = S.tiles[tile_index]\n        if not self._single_occurrence_of_option(S, tile_index, remove_options):\n            return False\n\n        if tile.n_options == 1:\n            tile.solved_at = self._stepper.counter\n            if not self._remove_option_from_neighbors(S, tile_index):\n                return False\n\n        return True\n\n\n    def _update_occurrences(self, S: Sudoku, tile_index: int, remove_options: set):\n\"\"\"\n        After removing `remove_options` from the tile at `tile_index`, we need\n        to make sure that this `tile_index` is no longer registered as a\n        position at which any of the candidates in `remove_options` occur.\n        \"\"\"\n\n        tile = S.tiles[tile_index]\n        for kind in CONTAINER_TYPES:\n            occurrence = S.occurrences[kind][tile.pos[kind]]\n            for o in remove_options:\n                occurrence[o-1] -= {tile_index}\n                if len(occurrence[o-1]) == 0:\n                    S.violated = True\n                    return False\n\n        return True\n\n    def _update_and_check_violations(self, S: Sudoku, tile_index: int, remove_options: set):\n\"\"\"\n        Invoke the process to update the lists that register at which positions\n        which candidates occur and check if Sudoku rules are violated by \n        verifying that the manipulated tile at `tile_index` still has more than\n        zero candidates left.\n        \"\"\"\n\n        if S.tiles[tile_index].n_options &gt; 0:\n            if self._update_occurrences(S, tile_index, remove_options):\n                return True\n\n        S.violated = True\n        return False\n\n    def _remove_and_check_violations(self, S: Sudoku, where: int, which: set) -&gt; bool:\n\"\"\"\n        Remove the candidates `which` from the tile at `where`.\n        \"\"\"\n\n        self._stepper.show_step(S, {where}, which)\n        S.tiles[where].options -= which\n        return self._update_and_check_violations(S, where, which)\n\n\n    def launch(self, S: Sudoku, where: int, which: set) -&gt; bool:\n        tile = S.tiles[where]\n        if (diff:=tile.options&amp;which):\n            if self._remove_and_check_violations(S, where, diff):\n                return self._update_chain_removal(S, where, diff)\n            else:\n                return False\n        else:\n            return False\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.RemoverMissingError","title":"<code>RemoverMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No remover has been assigned to the solving method.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class RemoverMissingError(NotImplementedError):\n\"\"\"\n    No remover has been assigned to the solving method.\n    \"\"\"\n    def __init__(self, method: str) -&gt; None:\n        super().__init__(f\"no remover has been set for solving method {method}\")\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.ScaledXWing","title":"<code>ScaledXWing</code>","text":"<p>         Bases: <code>FmtParamSolvingMethod</code></p> <p>Solving methods that searches for candidate options appearing in an  <code>n</code> x <code>n</code> square. </p> <p>Consider, e.g., two columns in which the same candidate occurs at exactly  two positions. Now, let the rows in which these occurrences are to be the same  for both columns. Then non of the remaining tiles within the latter tow rows  can take this candidate as value anymore as its position is already fixed to a place in either of the tow columns we considered initially.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class ScaledXWing(FmtParamSolvingMethod):\n\"\"\"\n    Solving methods that searches for candidate options appearing in an \n    `n` x `n` square. \n\n    Consider, e.g., two columns in which the same candidate occurs at exactly \n    two positions. Now, let the rows in which these occurrences are to be the same \n    for both columns. Then non of the remaining tiles within the latter tow rows \n    can take this candidate as value anymore as its position is already fixed to\n    a place in either of the tow columns we considered initially.\n    \"\"\"\n    _N_MIN = 2\n\n    def _find_option_in_n_by_n(self, S: Sudoku, n: int, primary_kind: str, option: int) -&gt; List[Set[int]]:\n        primary_kind_tiles: List[Set[int]] = []\n        secondary_kind, = {\"r\", \"c\"}-{primary_kind}\n        secondary_to_consider: List[Set[int]] = []\n        for occurrence in S.occurrences[primary_kind]:\n            if len(tile_idxs:=occurrence[option-1]) == n:\n                primary_kind_tiles.append(tile_idxs)\n                secondary_pos = {S.tiles[idx].pos[secondary_kind] for idx in tile_idxs}\n                secondary_to_consider.append(secondary_pos)\n                if secondary_to_consider.count(secondary_pos) == n:\n                    return [primary_kind_tiles[i] for i, sc_pos in enumerate(secondary_to_consider) if sc_pos==secondary_pos]\n\n        return None\n\n    def _option_in_n_by_n_removal(self, S: Sudoku, n: int, primary_kind: str, option: int):\n        throw_away = set()\n        secondary_kind, = {\"r\", \"c\"}-{primary_kind}\n        if (primary_kind_tiles:=self._find_option_in_n_by_n(S, n, primary_kind, option)):\n            found_tiles = {idx for idxs in primary_kind_tiles for idx in idxs}\n\n            for t_idx in primary_kind_tiles[0]:\n                tile = S.tiles[t_idx]\n                secondary_kind_occurrence = S.occurrences[secondary_kind][tile.pos[secondary_kind]]\n                secondary_kind_tiles = secondary_kind_occurrence[option-1]\n                throw_away |= (secondary_kind_tiles - found_tiles)\n\n            if len(throw_away) &gt; 0:\n                for t_idx in throw_away:\n                    self._stepper.set_consideration(\n                        found_tiles,\n                        {option},\n                        f\"found option {option} in {n}x{n} square at {found_tiles}, thus removing {option} from {t_idx}\",\n                        True)\n\n                    self._remove.launch(S, t_idx, {option})\n                    if S.violated:\n                        return False\n\n                return True\n\n            else:\n                return False     \n\n    def launch(self, S: Sudoku):\n        success = False\n        if S.done:\n            return S\n        else:\n            for direction in (\"r\", \"c\"):\n                for option in range(1, 10):\n                    if S.violated:\n                        return False\n\n                    if self._option_in_n_by_n_removal(S, self._n, direction, option):\n                        success = True\n\n            if success:\n                return self._advance.launch(S)\n            else:\n                return self._fall_back.launch(S)\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.SolverError","title":"<code>SolverError</code>","text":"<p>         Bases: <code>RuntimeError</code></p> <p>The puzzle can't be solved with the given solver.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class SolverError(RuntimeError):\n\"\"\"\n    The puzzle can't be solved with the given solver.\n    \"\"\"\n    def __init__(self) -&gt; None:\n        super().__init__(\"could not solve puzzle with the solving methods given\")\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.StepperMissingError","title":"<code>StepperMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No stepper has been assigned to the solving method.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class StepperMissingError(NotImplementedError):\n\"\"\"\n    No stepper has been assigned to the solving method. \n    \"\"\"\n    def __init__(self, method: str) -&gt; None:\n        super().__init__(f\"no stepper has been set for solving method {method}\")\n</code></pre>"},{"location":"api/sudoku/solvingmethods/#sudoku.solvingmethods.YWing","title":"<code>YWing</code>","text":"<p>         Bases: <code>FmtSolvingMethod</code></p> <p>Implementation of the classical 'Y-Wing' strategy.</p> <p>This methods first searches for an 'anchor' tile, i.e., a tile with two candidates left, say <code>{1,2}</code>. From this tile on, the neighboring row, column and square are searched for further 'two-candidate' tiles. The aim, thereby, is to find two more tiles, one of them including <code>1</code> and the other <code>2</code> as  candidate. Most importantly these two tiles must also have one common candidate, say <code>3</code>, such that we end up with two 'node' tiles related to the anchor, having candidates <code>{1,3}</code> and <code>{2,3}</code>. No matter what configuration  eventually solves the puzzle, one of the node tiles must be assigned the value <code>3</code> as fixing the value of one node immediately fixes the value of the other node via the anchor tile. Consequently, <code>3</code> can  be excluded as candidate from any tile that is simultaneously related to  both nodes.</p> Source code in <code>sudoku\\solvingmethods.py</code> <pre><code>class YWing(FmtSolvingMethod):\n\"\"\"\n    Implementation of the *classical* 'Y-Wing' strategy.\n\n    This methods first searches for an 'anchor' tile, i.e., a tile with two\n    candidates left, say `{1,2}`. From this tile on, the neighboring row, column\n    and square are searched for further 'two-candidate' tiles. The aim, thereby,\n    is to find two more tiles, one of them including `1` and the other `2` as \n    candidate. Most importantly these two tiles must also have one common candidate,\n    say `3`, such that we end up with two 'node' tiles related to the anchor,\n    having candidates `{1,3}` and `{2,3}`. No matter what configuration \n    eventually solves the puzzle, one of the node tiles must be\n    assigned the value `3` as fixing the value of one node immediately fixes\n    the value of the other node via the anchor tile. Consequently, `3` can \n    be excluded as candidate from any tile that is simultaneously related to \n    both nodes.\n    \"\"\"\n\n    def _get_node_candidates(self, S: Sudoku, anchor: Tile):\n        candidates = set()\n        for kind in CONTAINER_TYPES:\n            for t_idx in S.containers[kind][anchor.pos[kind]]:\n                tile = S.tiles[t_idx]\n                if (tile.n_options==2) and (len(tile.options&amp;anchor.options) == 1):\n                    candidates.add(t_idx)\n\n        candidates = list(candidates)\n        return candidates\n\n    def _eliminate_candidates(self, S: Sudoku, anchor: Tile, candidates: List[int]) -&gt; List[Tuple[int, int]]:\n        n_candidates = len(candidates)\n        if n_candidates &lt; 2:\n            return []\n\n        valid_pairs = []\n\n        for lcn in range(n_candidates-1):\n            left = S.tiles[candidates[lcn]]\n            for rcn in range(lcn+1, n_candidates):\n                right = S.tiles[candidates[rcn]]\n\n                if (anchor.options.issubset(right.options|left.options)) and (len(right.options&amp;left.options) == 1):\n                    valid_pairs.append((candidates[lcn], candidates[rcn]))\n\n        return valid_pairs\n\n    def _get_tile_range(self, S: Sudoku, tile: Tile):\n        tile_range = set()\n        for kind in CONTAINER_TYPES:\n            tile_range |= set(S.containers[kind][tile.pos[kind]])\n        return tile_range\n\n    def _find_y_wing_and_remove(self, S: Sudoku, anchor_index: int):\n        anchor = S.tiles[anchor_index]\n        valid_pairs = self._eliminate_candidates(S, anchor, self._get_node_candidates(S, anchor))\n        for pair in valid_pairs:\n            l, r = pair\n            l_tile = S.tiles[l]\n            r_tile = S.tiles[r]\n            considered_nodes = {l, r, anchor_index}\n            common_range = (self._get_tile_range(S, l_tile)&amp;self._get_tile_range(S, r_tile))-considered_nodes\n\n            if len(common_range)==0:\n                return False\n\n            else:\n                success = False\n\n                common_option = l_tile.options&amp;r_tile.options\n                for target in common_range:\n                    self._stepper.set_consideration(\n                        considered_nodes, anchor.options|l_tile.options|r_tile.options, \n                        f\"found Y-Wing with anchor at {anchor_index} and nodes at {l}, {r}, remove the shared option {common_option} from {target}\",\n                        True)\n\n                    if self._remove.launch(S, target, common_option):\n                        success = True\n                    if S.violated:\n                        return False\n\n                return success\n\n    def launch(self, S: Sudoku):\n        success = False\n        if S.done:\n            return S\n        else:\n            for anchor in filter(lambda idx: S.tiles[idx].n_options==2, range(81)):\n                if S.violated:\n                    return False\n\n                if self._find_y_wing_and_remove(S, anchor):\n                    success = True\n                    # return self._advance.launch(S)\n\n            if success:\n                return self._advance.launch(S)\n            else:\n                return self._fall_back.launch(S)\n</code></pre>"},{"location":"api/sudoku/stepping/","title":"stepping","text":"<p>This module provides the base for any 'stepper' class plus a few example steppers used in the default solver. The steppers are devices used as backend  for the formatted output of the solving process. Stepper objects provide an  interface for the solving method classes to pass information about any  successfully eliminated candidate. Moreover, they are able to pause the solving process after any successful elimination to pass the latter information to any frontend, thus enabling the user to step through the solving process, possibly by means of a graphical output.</p>"},{"location":"api/sudoku/stepping/#sudoku.stepping.AnyStep","title":"<code>AnyStep</code>","text":"<p>         Bases: <code>StepperBase</code></p> <p>Stepper class to transfer information about every elimination step to the frontend.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>class AnyStep(StepperBase):\n\"\"\"\n    Stepper class to transfer information about every elimination step to the\n    frontend.\n    \"\"\"\n\n    def set_consideration(self, tiles: set, options: set, message: str, interesting: bool = False):\n\"\"\"\n        Tell the stepper what `options` of what `tiles` we're currently \n        considering to draw conclusions about what candidates we can eliminate.\n        The `message` will be printed at a successful elimination. The\n        `interesting` parameter specifies the complexity of the consideration. \n        \"\"\"\n\n        self.considered_tiles = tiles\n        self.considered_options = options\n        self.solving_message = message\n        self.interesting = interesting\n\n    def show_step(self, sudoku: Sudoku, affected_tiles: set, affected_options: set):\n        self._increase()\n\n        self._fmt.render(\n            sudoku, \n            self.considered_tiles, \n            self.considered_options, \n            affected_tiles, \n            affected_options,\n            self.counter,\n            self.solving_message)\n        self._trg.trigger_next_step()\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.AnyStep.set_consideration","title":"<code>set_consideration(tiles, options, message, interesting=False)</code>","text":"<p>Tell the stepper what <code>options</code> of what <code>tiles</code> we're currently  considering to draw conclusions about what candidates we can eliminate. The <code>message</code> will be printed at a successful elimination. The <code>interesting</code> parameter specifies the complexity of the consideration.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>def set_consideration(self, tiles: set, options: set, message: str, interesting: bool = False):\n\"\"\"\n    Tell the stepper what `options` of what `tiles` we're currently \n    considering to draw conclusions about what candidates we can eliminate.\n    The `message` will be printed at a successful elimination. The\n    `interesting` parameter specifies the complexity of the consideration. \n    \"\"\"\n\n    self.considered_tiles = tiles\n    self.considered_options = options\n    self.solving_message = message\n    self.interesting = interesting\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.DeadStepper","title":"<code>DeadStepper</code>","text":"<p>         Bases: <code>StepperBase</code></p> <p>Trivial 'stepper' class serving as default value for any variable whose value must be of type <code>StepperBase</code>. That is, if no proper 'stepper' is assigned, this placeholder will raise an error whenever the user tries to  make use of the abstract methods that any stepper needs to implement.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>class DeadStepper(StepperBase):\n\"\"\"\n    Trivial 'stepper' class serving as default value for any variable whose\n    value must be of type `StepperBase`. That is, if no proper 'stepper' is\n    assigned, this placeholder will raise an error whenever the user tries to \n    make use of the abstract methods that any stepper needs to implement.\n    \"\"\"\n    def __init__(self, name: str) -&gt; None:\n        self._name = name\n\n    def set_consideration(self, *args):\n        raise StepperMissingError(self._name)\n\n    def show_step(self, *args):\n        raise StepperMissingError(self._name)\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.DeadTrigger","title":"<code>DeadTrigger</code>","text":"<p>         Bases: <code>NoTrigger</code></p> <p>Trivial trigger to raise an error when called. Such objects serve as  default argument for variables that take an object of type <code>NoTrigger</code> as value.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>class DeadTrigger(NoTrigger):\n\"\"\"\n    Trivial trigger to raise an error when called. Such objects serve as \n    default argument for variables that take an object of type `NoTrigger` as\n    value.\n    \"\"\"\n    def trigger_next_step(self):\n        raise TriggerMissingError()\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.InterestingStep","title":"<code>InterestingStep</code>","text":"<p>         Bases: <code>AnyStep</code></p> <p>Stepper with functionality analogous to <code>AnyStep</code> but only solving steps whose importance was set to 'interesting' by means of the respective  argument of the <code>set_consideration</code> method are rendered.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>class InterestingStep(AnyStep):\n\"\"\"\n    Stepper with functionality analogous to `AnyStep` but only solving steps\n    whose importance was set to 'interesting' by means of the respective \n    argument of the `set_consideration` method are rendered.\n    \"\"\"\n    def show_step(self, sudoku: Sudoku, affected_tiles: set, affected_options: set):\n        if self.interesting:\n            return super().show_step(sudoku, affected_tiles, affected_options)\n        else:\n            self._increase()\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.NoTrigger","title":"<code>NoTrigger</code>","text":"<p>Classes that implement the functionality to await any sort uf user input after the puzzle has been rendered.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>class NoTrigger:\n\"\"\"\n    Classes that implement the functionality to await any sort uf user input\n    after the puzzle has been rendered.\n    \"\"\"\n    def trigger_next_step(self):\n\"\"\"\n        Trigger the next solving step.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.NoTrigger.trigger_next_step","title":"<code>trigger_next_step()</code>","text":"<p>Trigger the next solving step.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>def trigger_next_step(self):\n\"\"\"\n    Trigger the next solving step.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.Skipper","title":"<code>Skipper</code>","text":"<p>         Bases: <code>StepperBase</code></p> <p>Trivial stepper class that only counts the solving steps without invoking any rendering or interrupting the solving process.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>class Skipper(StepperBase):\n\"\"\"\n    Trivial stepper class that only counts the solving steps without invoking\n    any rendering or interrupting the solving process.\n    \"\"\"\n    def __init__(self, formatter: BlankFormatter = None, trigger: NoTrigger = None) -&gt; None:\n        super().__init__(formatter, trigger)\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase","title":"<code>StepperBase</code>","text":"<p>Base class providing the template for any stepper by implementing a  solution-step counting mechanism and the interface to pass information about the current state of the puzzle through the stepper to the frontend.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>class StepperBase:\n\"\"\"\n    Base class providing the template for any stepper by implementing a \n    solution-step counting mechanism and the interface to pass information about\n    the current state of the puzzle through the stepper to the frontend.\n    \"\"\"\n    def __init__(self, formatter: BlankFormatter = None, trigger: NoTrigger = None) -&gt; None:\n\"\"\"\n        Create a stepper instance by passing a formatting function, i.e. a\n        function to render the puzzle with additional information about the\n        solving process\n        \"\"\"\n        self.counter = 0\n        self._fmt = formatter if formatter else DeadFormatter()\n        self._trg = trigger if trigger else DeadTrigger()\n\n    @abstractmethod\n    def set_consideration(self, tiles: set, options: set, message: str, interesting: bool = False):\n\"\"\"\n        Interface method trough which the implementations of the solving \n        algorithms can pass to the frontend.\n        \"\"\"\n        pass\n\n    def _increase(self):\n        self.counter += 1\n\n    @abstractmethod\n    def show_step(self, *args):\n\"\"\"\n        Invoke the frontend to print the current state of the Sudoku and \n        increase the solving step `counter` by one as this method is only called\n        after a successful elimination of a candidate.\n        \"\"\"\n        self._increase()\n\n    def show(self, sudoku: Sudoku):\n\"\"\"\n        Use the selected formatter to render the Sudoku without any information\n        about the solving process.\n        \"\"\"\n        self._fmt.render(sudoku, \n            solving_step=self.counter, solving_message=\"puzzle solved\")\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.__init__","title":"<code>__init__(formatter=None, trigger=None)</code>","text":"<p>Create a stepper instance by passing a formatting function, i.e. a function to render the puzzle with additional information about the solving process</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>def __init__(self, formatter: BlankFormatter = None, trigger: NoTrigger = None) -&gt; None:\n\"\"\"\n    Create a stepper instance by passing a formatting function, i.e. a\n    function to render the puzzle with additional information about the\n    solving process\n    \"\"\"\n    self.counter = 0\n    self._fmt = formatter if formatter else DeadFormatter()\n    self._trg = trigger if trigger else DeadTrigger()\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.set_consideration","title":"<code>set_consideration(tiles, options, message, interesting=False)</code>  <code>abstractmethod</code>","text":"<p>Interface method trough which the implementations of the solving  algorithms can pass to the frontend.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>@abstractmethod\ndef set_consideration(self, tiles: set, options: set, message: str, interesting: bool = False):\n\"\"\"\n    Interface method trough which the implementations of the solving \n    algorithms can pass to the frontend.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.show","title":"<code>show(sudoku)</code>","text":"<p>Use the selected formatter to render the Sudoku without any information about the solving process.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>def show(self, sudoku: Sudoku):\n\"\"\"\n    Use the selected formatter to render the Sudoku without any information\n    about the solving process.\n    \"\"\"\n    self._fmt.render(sudoku, \n        solving_step=self.counter, solving_message=\"puzzle solved\")\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperBase.show_step","title":"<code>show_step(*args)</code>  <code>abstractmethod</code>","text":"<p>Invoke the frontend to print the current state of the Sudoku and  increase the solving step <code>counter</code> by one as this method is only called after a successful elimination of a candidate.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>@abstractmethod\ndef show_step(self, *args):\n\"\"\"\n    Invoke the frontend to print the current state of the Sudoku and \n    increase the solving step `counter` by one as this method is only called\n    after a successful elimination of a candidate.\n    \"\"\"\n    self._increase()\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.StepperMissingError","title":"<code>StepperMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No stepper has been assigned to the solving method.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>class StepperMissingError(NotImplementedError):\n\"\"\"\n    No stepper has been assigned to the solving method. \n    \"\"\"\n    def __init__(self, method: str) -&gt; None:\n        super().__init__(f\"no stepper has been set for solving method {method}\")\n</code></pre>"},{"location":"api/sudoku/stepping/#sudoku.stepping.TriggerMissingError","title":"<code>TriggerMissingError</code>","text":"<p>         Bases: <code>NotImplementedError</code></p> <p>No trigger has been assigned to the stepper.</p> Source code in <code>sudoku\\stepping.py</code> <pre><code>class TriggerMissingError(NotImplementedError):\n\"\"\"\n    No trigger has been assigned to the stepper.\n    \"\"\"\n    def __init__(self) -&gt; None:\n        super().__init__(\"no trigger has been assigned to the stepper\")\n</code></pre>"},{"location":"api/sudoku/structure/","title":"structure","text":"<p>This module provides the two classes <code>Tile</code> and <code>Sudoku</code> that serve as base structure for the solver to operate on. Observe that the abbreviations 'r', 'c' and 's' for row, column and square, stored in <code>CONTAINER_TYPES</code>, are used throughout this program. Square, thereby, refers to typical 3x3 tile  collections.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku","title":"<code>Sudoku</code>","text":"<p>Container structure to represent the Sudoku grid by storing 81 <code>Tile</code>  objects in a one dimensional list.</p> Source code in <code>sudoku\\structure.py</code> <pre><code>class Sudoku:\n\"\"\"\n    Container structure to represent the Sudoku grid by storing 81 `Tile` \n    objects in a one dimensional list. \n    \"\"\"\n    def __init__(self, content: List[int]) -&gt; None:\n        self.violated = False\n\n        self._tiles: List[Tile] = []\n        self._containers: Dict[str, List[List[int]]] = {}\n        self._occurrences: Dict[str, List[List[Set[int]]]] = {}\n\n        for kind in CONTAINER_TYPES:\n            self._occurrences[kind] = [[set() for _ in range(9)] for _ in range(9)]\n            self._containers[kind] = [[] for _ in range(9)]\n\n        given_tiles: List[int] = []\n        for tile_index in range(81):\n            tile = Tile(**index_to_pos(tile_index))\n            if val:=content[tile_index]:\n                tile.options = {val}\n                given_tiles.append(tile_index)\n\n            for kind in CONTAINER_TYPES:\n                self._containers[kind][tile.pos[kind]].append(tile_index)\n\n                occurrence = self._occurrences[kind][tile.pos[kind]]\n                for o in tile.options:\n                    occurrence[o-1].add(tile_index)\n\n            self._tiles.append(tile)\n\n        for tile_index in given_tiles:\n            tile = self._tiles[tile_index]\n\n            # option 'o' has occurrence position 'o-1'\n            option_occurrence_pos = list(tile.options)[0]-1\n\n            for kind in CONTAINER_TYPES:\n                occurrence = self._occurrences[kind][tile.pos[kind]]\n                occurrence[option_occurrence_pos] = {tile_index}\n\n    @property\n    def max_options(self) -&gt; int:\n\"\"\"\n        Returns the maximum number of candidates over all the tiles.\n        \"\"\"\n        return max(tile.n_options for tile in self._tiles)\n\n    @property\n    def done(self) -&gt; bool:\n\"\"\"\n        Returns whether the puzzle has been solved.\n        \"\"\"\n        return True if self.max_options==1 and not self.violated else False\n\n    @property\n    def tiles(self) -&gt; List[Tile]:\n\"\"\"\n        List of length 81 to store every tile of the Sudoku grid.\n        \"\"\"\n        return self._tiles\n\n    @property\n    def containers(self) -&gt; Dict[str, List[List[int]]]:\n\"\"\"\n        Structure to store the indices of the tiles, i.e. their position in the\n        `tiles` array, that live in each row, column and square. \n\n        Consider the following example to retrieve the array positions of the \n        tiles that live in the first square:\n\n        Examples:\n            &gt;&gt;&gt; Sudoku.containers['s'][0]\n            [0, 1, 2, 9, 10, 11, 18, 19, 20]\n\n        Thereby, the subscript `['s'][0]` indicates the square at position 0.\n\n        Returns:\n            the containers\n        \"\"\"\n        return self._containers\n\n    @property\n    def occurrences(self) -&gt; Dict[str, List[List[Set[int]]]]:\n\"\"\"\n        For each row, column and square and for each number of 1 to 9, this \n        dictionary stores at which `tiles` positions the respective value still \n        appears as candidate.\n\n        Example: Retrieve the set of array positions at which the candidate `9`\n        is still found in the second row by\n\n        &gt;&gt;&gt; Sudoku.occurrences['r'][1][8]\n        &gt;&gt;&gt; {9, 11, 15}\n\n        where `['r'][1]` indicates the second row and `[8]` specifies the list\n        position at which the occurrences of the value `9` are stored.\n        \"\"\"\n        return self._occurrences\n\n    def is_valid(self) -&gt; bool:\n\"\"\"\n        Explicitly check whether the Sudoku rules have been violated in the \n        solving process. One should try to avoid explicit use of this method as\n        the implementations of the solving algorithms should automatically \n        detect if such a violation has been taken place and correspondingly set \n        the `violated` attribute to `True`.\n        \"\"\"\n        if not self.violated:\n            goal = set(range(1,10))\n            for kind in CONTAINER_TYPES:\n                for i in range(9):\n                    container = self._containers[kind][i]\n                    options = set()\n                    for tile_index in container:\n                        options |= self._tiles[tile_index].options\n\n                    if not options == goal:\n                        print(f\"error at {kind} {i}\")\n                        return False\n\n            return True\n        else:\n            return False\n\n    def get_tiles(self) -&gt; List[List[Tile]]:\n\"\"\"\n        Returns the tiles organized row by row.\n        \"\"\"\n        return [[t for t in self._tiles[9*r:9*(r+1)]] for r in range(9)]\n\n    def get_options(self) -&gt; List[List[set]]:\n\"\"\"\n        Returns the remaining candidates for each tile as set organized row by \n        row.\n        \"\"\"\n        return [[t.options for t in self._tiles[9*r:9*(r+1)]] for r in range(9)]\n\n    def get_solved(self) -&gt; List[List[int]]:\n\"\"\"\n        Returns the solved puzzle as a two-dimensional list.\n        \"\"\"\n        if self.done:\n            return [[list(tile.options)[0] for tile in row] for row in self.get_tiles()]\n        else:\n            raise RuntimeError(\"Puzzle is not solved yet.\")\n\n    def get_complexity_map(self) -&gt; List[List[int]]:\n\"\"\"\n        Returns the solving step a which the definite solution has been found \n        for each tile (organized row by row).\n        \"\"\"\n        return [[tile.solved_at for tile in row] for row in self.get_tiles()]\n</code></pre>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.containers","title":"<code>containers: Dict[str, List[List[int]]]</code>  <code>property</code>","text":"<p>Structure to store the indices of the tiles, i.e. their position in the <code>tiles</code> array, that live in each row, column and square. </p> <p>Consider the following example to retrieve the array positions of the  tiles that live in the first square:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Sudoku.containers['s'][0]\n[0, 1, 2, 9, 10, 11, 18, 19, 20]\n</code></pre> <p>Thereby, the subscript <code>['s'][0]</code> indicates the square at position 0.</p> <p>Returns:</p> Type Description <code>Dict[str, List[List[int]]]</code> <p>the containers</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.done","title":"<code>done: bool</code>  <code>property</code>","text":"<p>Returns whether the puzzle has been solved.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.max_options","title":"<code>max_options: int</code>  <code>property</code>","text":"<p>Returns the maximum number of candidates over all the tiles.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.occurrences","title":"<code>occurrences: Dict[str, List[List[Set[int]]]]</code>  <code>property</code>","text":"<p>For each row, column and square and for each number of 1 to 9, this  dictionary stores at which <code>tiles</code> positions the respective value still  appears as candidate.</p> <p>Example: Retrieve the set of array positions at which the candidate <code>9</code> is still found in the second row by</p> <p>Sudoku.occurrences'r'[8] {9, 11, 15}</p> <p>where <code>['r'][1]</code> indicates the second row and <code>[8]</code> specifies the list position at which the occurrences of the value <code>9</code> are stored.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.tiles","title":"<code>tiles: List[Tile]</code>  <code>property</code>","text":"<p>List of length 81 to store every tile of the Sudoku grid.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_complexity_map","title":"<code>get_complexity_map()</code>","text":"<p>Returns the solving step a which the definite solution has been found  for each tile (organized row by row).</p> Source code in <code>sudoku\\structure.py</code> <pre><code>def get_complexity_map(self) -&gt; List[List[int]]:\n\"\"\"\n    Returns the solving step a which the definite solution has been found \n    for each tile (organized row by row).\n    \"\"\"\n    return [[tile.solved_at for tile in row] for row in self.get_tiles()]\n</code></pre>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_options","title":"<code>get_options()</code>","text":"<p>Returns the remaining candidates for each tile as set organized row by  row.</p> Source code in <code>sudoku\\structure.py</code> <pre><code>def get_options(self) -&gt; List[List[set]]:\n\"\"\"\n    Returns the remaining candidates for each tile as set organized row by \n    row.\n    \"\"\"\n    return [[t.options for t in self._tiles[9*r:9*(r+1)]] for r in range(9)]\n</code></pre>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_solved","title":"<code>get_solved()</code>","text":"<p>Returns the solved puzzle as a two-dimensional list.</p> Source code in <code>sudoku\\structure.py</code> <pre><code>def get_solved(self) -&gt; List[List[int]]:\n\"\"\"\n    Returns the solved puzzle as a two-dimensional list.\n    \"\"\"\n    if self.done:\n        return [[list(tile.options)[0] for tile in row] for row in self.get_tiles()]\n    else:\n        raise RuntimeError(\"Puzzle is not solved yet.\")\n</code></pre>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.get_tiles","title":"<code>get_tiles()</code>","text":"<p>Returns the tiles organized row by row.</p> Source code in <code>sudoku\\structure.py</code> <pre><code>def get_tiles(self) -&gt; List[List[Tile]]:\n\"\"\"\n    Returns the tiles organized row by row.\n    \"\"\"\n    return [[t for t in self._tiles[9*r:9*(r+1)]] for r in range(9)]\n</code></pre>"},{"location":"api/sudoku/structure/#sudoku.structure.Sudoku.is_valid","title":"<code>is_valid()</code>","text":"<p>Explicitly check whether the Sudoku rules have been violated in the  solving process. One should try to avoid explicit use of this method as the implementations of the solving algorithms should automatically  detect if such a violation has been taken place and correspondingly set  the <code>violated</code> attribute to <code>True</code>.</p> Source code in <code>sudoku\\structure.py</code> <pre><code>def is_valid(self) -&gt; bool:\n\"\"\"\n    Explicitly check whether the Sudoku rules have been violated in the \n    solving process. One should try to avoid explicit use of this method as\n    the implementations of the solving algorithms should automatically \n    detect if such a violation has been taken place and correspondingly set \n    the `violated` attribute to `True`.\n    \"\"\"\n    if not self.violated:\n        goal = set(range(1,10))\n        for kind in CONTAINER_TYPES:\n            for i in range(9):\n                container = self._containers[kind][i]\n                options = set()\n                for tile_index in container:\n                    options |= self._tiles[tile_index].options\n\n                if not options == goal:\n                    print(f\"error at {kind} {i}\")\n                    return False\n\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile","title":"<code>Tile</code>","text":"<p>Structure to represent a tile of the Sudoku grid. Tile objects store the  position of a tile by means of specifying their row, column and square  index. Moreover, this class is needed to keep track of the possible  candidate values a tile can still take in the process of solving the puzzle.</p> Source code in <code>sudoku\\structure.py</code> <pre><code>class Tile:\n\"\"\"\n    Structure to represent a tile of the Sudoku grid. Tile objects store the \n    position of a tile by means of specifying their row, column and square \n    index. Moreover, this class is needed to keep track of the possible \n    candidate values a tile can still take in the process of solving the puzzle.\n    \"\"\"\n    def __init__(self, r: int, c: int, s: int) -&gt; None:\n        self._pos = {\"r\": r, \"c\": c, \"s\": s}\n        self._options = set(range(1, 10))\n        self.n_options = 9\n        self.solved_at = 0\n\n    def __getitem__(self, key: str):\n        return self._pos[key]\n\n    @property\n    def pos(self) -&gt; Dict[str, int]:\n\"\"\"\n        Get the row, column and square index of the tile formatted as\n        `{'r': *row index*, 'c': *column index*, 's': *square index*}`.\n        \"\"\"\n        return self._pos\n\n    @property\n    def options(self) -&gt; set:\n\"\"\"\n        Get the remaining candidate values for this tile.\n        \"\"\"\n        return self._options\n\n    @options.setter\n    def options(self, new_options) -&gt; None:\n        self._options = new_options\n        self.n_options = len(new_options)\n\n    @classmethod\n    def to_none_tile(cls, tile: Tile) -&gt; Tile:\n\"\"\"\n        Create a tile that has no candidate values at the position of the \n        `tile` that is given as argument.\n        \"\"\"\n        obj = super().__new__(cls)\n        obj._pos = tile._pos\n        obj._options = {}\n        obj.n_options = 0\n        return obj\n</code></pre>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile.options","title":"<code>options: set</code>  <code>property</code> <code>writable</code>","text":"<p>Get the remaining candidate values for this tile.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile.pos","title":"<code>pos: Dict[str, int]</code>  <code>property</code>","text":"<p>Get the row, column and square index of the tile formatted as <code>{'r': *row index*, 'c': *column index*, 's': *square index*}</code>.</p>"},{"location":"api/sudoku/structure/#sudoku.structure.Tile.to_none_tile","title":"<code>to_none_tile(tile)</code>  <code>classmethod</code>","text":"<p>Create a tile that has no candidate values at the position of the  <code>tile</code> that is given as argument.</p> Source code in <code>sudoku\\structure.py</code> <pre><code>@classmethod\ndef to_none_tile(cls, tile: Tile) -&gt; Tile:\n\"\"\"\n    Create a tile that has no candidate values at the position of the \n    `tile` that is given as argument.\n    \"\"\"\n    obj = super().__new__(cls)\n    obj._pos = tile._pos\n    obj._options = {}\n    obj.n_options = 0\n    return obj\n</code></pre>"},{"location":"api/sudoku/structure/#sudoku.structure.index_to_pos","title":"<code>index_to_pos(t)</code>","text":"<p>Get the row, column and square index from the tile index <code>t</code> formatted as  <code>{'r': *row index*, 'c': *column index*, 's': *square index*}</code>.</p> Source code in <code>sudoku\\structure.py</code> <pre><code>def index_to_pos(t) -&gt; Dict[str, int]:\n\"\"\"\n    Get the row, column and square index from the tile index `t` formatted as \n    `{'r': *row index*, 'c': *column index*, 's': *square index*}`.\n    \"\"\"\n    return {\"r\": (r:=t//9), \"c\": (c:=t%9), \"s\": 3*(r//3) + c//3}\n</code></pre>"},{"location":"api/sudoku/structure/#sudoku.structure.row_column_to_index","title":"<code>row_column_to_index(r, c)</code>","text":"<p>Get the tile index, i.e. the position of the tile in an array of dimension <code>81</code>, by specifying the row <code>r</code> and the column <code>c</code>.</p> Source code in <code>sudoku\\structure.py</code> <pre><code>def row_column_to_index(r: int, c: int) -&gt; int:\n\"\"\"\n    Get the tile index, i.e. the position of the tile in an array of dimension\n    `81`, by specifying the row `r` and the column `c`.\n    \"\"\"\n    return r*9+c\n</code></pre>"}]}