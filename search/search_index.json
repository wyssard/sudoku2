{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sudokumentation","text":""},{"location":"#welcome-to-the-documentation-of-the-sudoku2-package","title":"Welcome to the documentation of the sudoku2 package!","text":"<p>These docs try to give you an overview of the different aspects and use cases of the package. </p> <p>On the one hand, its built in solver can be comfortably used to guide you step-by-step to the solution of a Sudoku puzzle. On the other hand, the package provides an API which lets you easily extend the capabilities of the basic solver by adding custom solving algorithms or by implementing any arbitrary Python frontend to render the individual solving steps. </p> <p>Warning Even the core functionality of the Package is still in development. Both the API and the features that are abstracted by it may still change heavily. Proceed with caution if you intend to integrate this package in your own project. Moreover, if you are reading this from a development branch, the docs may not exactly correspond to the present state of the code.</p>"},{"location":"#contents","title":"Contents","text":"<p>Info For any use of the package that goes beyond the Standard Solver, it's strongly recommended to start the journey through these docs with the description of the Solving Process. </p> <p>If you intend to use the package as a stand-alone tool to solve Sudoku puzzles, please refer to:</p> <ul> <li>Standard Solver - simple functional access to the pre-built solver</li> <li>Custom Solver - create a custom solver by explicitly deciding what solving algorithms to use and what solving steps to render</li> </ul> <p>If you're interested in modifying the basic capabilities or to use the solver backend in your own project, refer to the API Guide.</p>"},{"location":"api_guide/","title":"API Guide","text":""},{"location":"custom_solver/","title":"Create a Custom Solver","text":"<p>This document aims at explaining the API of the library by walking you through the process of assembling a custom solver object. We will thereby create an implementation for a very basic solving algorithm and </p>"},{"location":"solving_process/","title":"Solving Process","text":"<p>When working with the Custom Solver or when making use of the API, your interaction with the package goes beyond the simplified functional access and you will be confronted with the objects that, e.g., represent the solving algorithms of the rendering frontend. In order to understand how these objects interact with each other, a basic understanding of the solving procedure, illustrated by the flowchart below, is indispensible.</p> <p>We come back to some specific nodes of the diagram when discussing the API or the Custom Solver generator.</p>"},{"location":"solving_process/#a-word-of-caution","title":"A Word of Caution","text":"<p>Since there are some severe differences between the implemented solving algorithms, the API does not force you (so far) to entirely stick to the prescription suggested by the diagram. For example, you are free to decide whether to implement a loop over tiles or to replace it by a better suiting approach.</p> <p>Future versions may address this inconvenience by providing a further abstraction that ultimately forces you to stick to the suggested prescription by means of an intermediate abstract class. Since, however, the procedures that are not abstracted are very simple (they come in form of simple conditions or loops), further abstraction may also be omitted completely, to make the code more readable.</p>"},{"location":"solving_process/#flowchart","title":"Flowchart","text":"<pre><code>flowchart\n    init([Launch Solver]) --&gt; InitialAlgorithm[Use initial Algorithm]\n    InitialAlgorithm --&gt; LaunchSolver[Launch Algorithm] \n    LaunchSolver --&gt; Solved{Puzzle \\nsolved?}\n\n    Solved --yes--&gt; Return([Return Solved Puzzle])\n\n    Solved --no---&gt; SolverLoop[Loop over Tiles]\n    SolverLoop --&gt; Increase[Next Tile]\n    Increase --&gt; TerminateLoop{Last \\nitem?}\n\n    TerminateLoop --Yes--&gt; CheckSuccess{Algorithm \\ncould remove \\nat least one\\n candidate?}\n\n    CheckSuccess --No---&gt; FallbackLeft{Fallback \\nAlgorithm \\nspecified?}\n    FallbackLeft --yes--&gt; Fallback[Continue with Fallback Algorithm]\n\n    CheckSuccess --yes--&gt; Advance[Continue with less elaborate Algorithm]\n    Fallback &amp; Advance --&gt; LaunchSolver\n\n    FallbackLeft --no--&gt; Fail([Can't solve puzzle])\n\n    TerminateLoop --No--&gt; FindPattern[[Search for Pattern on the Sudoku grid \\nthat lets us deduce \\nwhat Candidates we can remove \\nfrom neighboring Tiles]]\n    FindPattern --&gt; PatternFound{Pattern \\nmatched?}\n\n    PatternFound --no--&gt; Increase\n\n    PatternFound --yes--&gt; TryRemove[Check if there are any Candidates \\nconcerned by the Pattern]\n    TryRemove --&gt; ToRemove{Concerned\\ncandidates\\nfound?}\n\n    ToRemove --no--&gt; Increase\n\n    ToRemove --yes--&gt; Remove[Remove Candidates]\n    Remove --&gt; Render{{Render Solving Step}}\n    Render --&gt; Trigger[Trigger Next Step]\n    Trigger --&gt; CleanUp[[Update Routine involving very basic Solving Algorithms]]\n    CleanUp --&gt; Increase\n</code></pre>"},{"location":"standard_solvers/","title":"Using the Standard Solver","text":""},{"location":"api/modules/","title":"Modules","text":""}]}